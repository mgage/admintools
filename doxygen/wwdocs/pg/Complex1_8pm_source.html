<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PG: Complex1.pm Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>Complex1.pm</h1><a href="Complex1_8pm.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor"># Complex numbers and associated mathematical functions</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor"># -- Raphael Manfredi   Since Sep 1996</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="preprocessor"># -- Jarkko Hietaniemi  Since Mar 1997</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span><span class="preprocessor"># -- Daniel S. Lewart   Since Sep 1997</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span>
<a name="l00008"></a>00008 require Exporter;
<a name="l00009"></a>00009 <span class="keyword">package </span>Complex1;
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 use strict;
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 use vars qw($VERSION @ISA @EXPORT %EXPORT_TAGS);
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 my ( $i, $ip2, %<a class="code" href="classComplex1.html#ab3a286207d26502721719051c2d96748">logn</a> );
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 $VERSION = sprintf(<span class="stringliteral">&quot;%s&quot;</span>, q$Id$ =~ /(\d+\.\d+)/);
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 @ISA = qw(Exporter);
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 my @trig = qw(
<a name="l00022"></a>00022           pi
<a name="l00023"></a>00023           <a class="code" href="classComplex1.html#afd0ac52e051f46995d8b2c5008db3246">tan</a>
<a name="l00024"></a>00024           <a class="code" href="classComplex1.html#aefa08cd87317ae783e203a0ea71ed506">csc</a> <a class="code" href="classComplex1.html#a33257efabf2c8a76e6823b4468669d88">cosec</a> <a class="code" href="classComplex1.html#ad7dcac2313b671bf5d18596093ca0814">sec</a> <a class="code" href="classComplex1.html#a1bab47b2a0917a700df4c6bbf311a961">cot</a> <a class="code" href="classComplex1.html#adde3f4db3297384f67c31a913c9bcb9b">cotan</a>
<a name="l00025"></a>00025           <a class="code" href="classComplex1.html#ac5a0b8a37861c1e82a87ae1991184ac4">asin</a> <a class="code" href="classComplex1.html#aed051eaa27353fff16d6de93d0546dbd">acos</a> <a class="code" href="classComplex1.html#a57e467c73efe8597bd0fc8a776c57e3d">atan</a>
<a name="l00026"></a>00026           <a class="code" href="classComplex1.html#aa706ae688fdc5f92902c808ad6c5f2bb">acsc</a> <a class="code" href="classComplex1.html#a96ead8a16587f6b459518f0e754920fd">acosec</a> <a class="code" href="classComplex1.html#a894adbe7f359f94795783d816e33005c">asec</a> <a class="code" href="classComplex1.html#a15088c85f8e4f39d9511ae9f16797b59">acot</a> <a class="code" href="classComplex1.html#a4ab9e4e8b481fd279c9ce0e65523a114">acotan</a>
<a name="l00027"></a>00027           <a class="code" href="classComplex1.html#ac1d4f7d86e9bd2be8df6ba7c1f7aaf5a">sinh</a> <a class="code" href="classComplex1.html#afe2d48779335736ce8f7a69e4aafb31a">cosh</a> <a class="code" href="classComplex1.html#ae7629469d5a8114e7853c65e8990b48f">tanh</a>
<a name="l00028"></a>00028           <a class="code" href="classComplex1.html#a50951e70ec11a51c1d812141048f8a55">csch</a> <a class="code" href="classComplex1.html#aef8d9ca97effbdff3b5e342054c1ade4">cosech</a> <a class="code" href="classComplex1.html#a5a877aedae65989b8aa995c4a393b9ed">sech</a> <a class="code" href="classComplex1.html#a38c6deae852f200bffe38decb9982a10">coth</a> <a class="code" href="classComplex1.html#ad29ac776a755c2668c66cd5345750e2d">cotanh</a>
<a name="l00029"></a>00029           <a class="code" href="classComplex1.html#afd4c118bb9a7107383641deb0c8ab622">asinh</a> <a class="code" href="classComplex1.html#a9095b8865cfe49c8430e2e005cf1f57a">acosh</a> <a class="code" href="classComplex1.html#a60f2955efc3ca8faccf7e8f8e3115c67">atanh</a>
<a name="l00030"></a>00030           <a class="code" href="classComplex1.html#a9e4da5c7215a7c6a00e0b31ecef1ba7d">acsch</a> <a class="code" href="classComplex1.html#a327ebee0f6d8113f3d9c6d0b8ae8f643">acosech</a> <a class="code" href="classComplex1.html#a64572c68967e1b0b0fa45fd833a5a08d">asech</a> <a class="code" href="classComplex1.html#a9c7337bd2d1999c21294e65c090d6f00">acoth</a> <a class="code" href="classComplex1.html#a66e0683218a5ac973b811ff6fb11eb7e">acotanh</a>
<a name="l00031"></a>00031          );
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 @EXPORT = (qw(
<a name="l00034"></a>00034          <a class="code" href="classComplex1.html#afdb18f08d4ab9b6f7d3851e789735ae5">i</a> <a class="code" href="classComplex1.html#a282805a706a111c3eee6b9c7950a1893">Re</a> <a class="code" href="classComplex1.html#a5d2b6e9c6a6e480809f2005d17f90af9">Im</a> <a class="code" href="classComplex1.html#a1dfbe8f922985e262c82d0a25ed4fe7e">rho</a> <a class="code" href="classComplex1.html#a8f72e2281cea85785da08421a3561feb">theta</a> <a class="code" href="classComplex1.html#a991040a76389558c2a0a57a32c8b64aa">arg</a>
<a name="l00035"></a>00035          <a class="code" href="classComplex1.html#a1f30a6a23cb095b6b9651f15631d1a8f">sqrt</a> <a class="code" href="classComplex1.html#a2dae55373f4ea96e452e578a741d12f7">log</a> <a class="code" href="classComplex1.html#ad18ecc2c4d75557c416140a7a1222bc7">ln</a>
<a name="l00036"></a>00036          <a class="code" href="classComplex1.html#ab036e29ba7a72beff5b20921fe288b64">log10</a> <a class="code" href="classComplex1.html#ab3a286207d26502721719051c2d96748">logn</a> <a class="code" href="classComplex1.html#a991d93062ba99dd8375bbda14319b3f5">cbrt</a> <a class="code" href="classComplex1.html#a4ae8316526aba7ec1546a2d6642a396b">root</a>
<a name="l00037"></a>00037          <a class="code" href="classComplex1.html#a5048919ea9b07d196e26402b7e56bb22">cplx</a> <a class="code" href="classComplex1.html#a08c15f79f424b56541002721042685b7">cplxe</a>
<a name="l00038"></a>00038          ),
<a name="l00039"></a>00039        @trig);
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 %EXPORT_TAGS = (
<a name="l00042"></a>00042     <span class="stringliteral">&#39;trig&#39;</span> =&gt; [@trig],
<a name="l00043"></a>00043 );
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 use overload
<a name="l00046"></a>00046     <span class="charliteral">&#39;+&#39;</span> =&gt; \&amp;<a class="code" href="classComplex1.html#a7cfacdfa68909d627965d50a9d7b6ce5">plus</a>,
<a name="l00047"></a>00047     <span class="charliteral">&#39;-&#39;</span> =&gt; \&amp;<a class="code" href="classComplex1.html#a83648f6a1be1020c255b33ef5afbce65">minus</a>,
<a name="l00048"></a>00048     <span class="charliteral">&#39;*&#39;</span> =&gt; \&amp;<a class="code" href="classComplex1.html#a16857673e7cb387e235d08d275e4f91d">multiply</a>,
<a name="l00049"></a>00049     <span class="charliteral">&#39;/&#39;</span> =&gt; \&amp;<a class="code" href="classComplex1.html#a8e9bd1892f1b8c029d4cbd4fe81a804c">divide</a>,
<a name="l00050"></a>00050     <span class="stringliteral">&#39;**&#39;</span>    =&gt; \&amp;<a class="code" href="classComplex1.html#a11de7e1bc38a0e4cba63c30aa58eec90">power</a>,
<a name="l00051"></a>00051     <span class="stringliteral">&#39;&lt;=&gt;&#39;</span>   =&gt; \&amp;<a class="code" href="classComplex1.html#a185236b3b2d6624728e3687a446fae01">spaceship</a>,
<a name="l00052"></a>00052     <span class="stringliteral">&#39;neg&#39;</span>   =&gt; \&amp;<a class="code" href="classComplex1.html#aff41ea81696327e485af58ba3ae6b585">negate</a>,
<a name="l00053"></a>00053     <span class="charliteral">&#39;~&#39;</span> =&gt; \&amp;<a class="code" href="classComplex1.html#a26fa67ffa18fa2da096fde9db45fc475">conjugate</a>,
<a name="l00054"></a>00054     <span class="stringliteral">&#39;abs&#39;</span>   =&gt; \&amp;<a class="code" href="classComplex1.html#a2441c6180fe0532fa21c7cfa3875c004">abs</a>,
<a name="l00055"></a>00055     <span class="stringliteral">&#39;sqrt&#39;</span>  =&gt; \&amp;<a class="code" href="classComplex1.html#a1f30a6a23cb095b6b9651f15631d1a8f">sqrt</a>,
<a name="l00056"></a>00056     <span class="stringliteral">&#39;exp&#39;</span>   =&gt; \&amp;<a class="code" href="classComplex1.html#a1f0b04927b2c3df399542614324b9f5c">exp</a>,
<a name="l00057"></a>00057     <span class="stringliteral">&#39;log&#39;</span>   =&gt; \&amp;<a class="code" href="classComplex1.html#a2dae55373f4ea96e452e578a741d12f7">log</a>,
<a name="l00058"></a>00058     <span class="stringliteral">&#39;sin&#39;</span>   =&gt; \&amp;<a class="code" href="classComplex1.html#ac31d7090ed445256a96a7b7088aedb87">sin</a>,
<a name="l00059"></a>00059     <span class="stringliteral">&#39;cos&#39;</span>   =&gt; \&amp;<a class="code" href="classComplex1.html#aad4b78cf4a8574a8a6768b5a687a8bba">cos</a>,
<a name="l00060"></a>00060     <span class="stringliteral">&#39;tan&#39;</span>   =&gt; \&amp;<a class="code" href="classComplex1.html#afd0ac52e051f46995d8b2c5008db3246">tan</a>,
<a name="l00061"></a>00061     <span class="stringliteral">&#39;atan2&#39;</span> =&gt; \&amp;<a class="code" href="classComplex1.html#abc0c494ace9e91a8b49614258ef18cd4">atan2</a>,
<a name="l00062"></a>00062     qw(<span class="stringliteral">&quot;&quot;</span> <a class="code" href="classComplex1.html#a683efdf56168153dcb352e0e5b290e79">stringify</a>);
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="preprocessor">#</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor"># Package &quot;privates&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00068"></a>00068 <span class="preprocessor">#my $package = &#39;Math::Complex&#39;;     # Package name</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span>my $package = <span class="stringliteral">&#39;Complex1&#39;</span>;
<a name="l00070"></a>00070 my $display = <span class="stringliteral">&#39;cartesian&#39;</span>;      # Default display format
<a name="l00071"></a>00071 my $eps     = 1e-14;            # Epsilon
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="preprocessor">#</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor"># Object attributes (internal):</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#   cartesian   [real, imaginary] -- cartesian form</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#   polar       [rho, theta] -- polar form</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">#   c_dirty     cartesian form not up-to-date</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#   p_dirty     polar form not up-to-date</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#   display     display format (package&#39;s global when not set)</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>
<a name="l00082"></a>00082 <span class="preprocessor"># Die on bad *make() arguments.</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>
<a name="l00084"></a>00084 sub <a class="code" href="classComplex1.html#a4cbce7a9a2cc78ef7949bbb2a8201614">_cannot_make</a> {
<a name="l00085"></a>00085     die <span class="stringliteral">&quot;@{[(caller(1))[3]]}: Cannot take $_[0] of $_[1].\n&quot;</span>;
<a name="l00086"></a>00086 }
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="preprocessor">#</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="preprocessor"># -&gt;make</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor"># Create a new complex number (cartesian form)</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span>sub <a class="code" href="classComplex1.html#a0d9c26fc07a996258bbd621812154094">make</a> {
<a name="l00094"></a>00094     my $self = bless {}, shift;
<a name="l00095"></a>00095     my ($re, $im) = @_;
<a name="l00096"></a>00096     my $rre = ref $re;
<a name="l00097"></a>00097     <span class="keywordflow">if</span> ( $rre ) {
<a name="l00098"></a>00098         <span class="keywordflow">if</span> ( $rre eq ref $self ) {
<a name="l00099"></a>00099         $re = <a class="code" href="classComplex1.html#a282805a706a111c3eee6b9c7950a1893">Re</a>($re);
<a name="l00100"></a>00100         } <span class="keywordflow">else</span> {
<a name="l00101"></a>00101         <a class="code" href="classComplex1.html#a4cbce7a9a2cc78ef7949bbb2a8201614">_cannot_make</a>(<span class="stringliteral">&quot;real part&quot;</span>, $rre);
<a name="l00102"></a>00102         }
<a name="l00103"></a>00103     }
<a name="l00104"></a>00104     my $rim = ref $im;
<a name="l00105"></a>00105     <span class="keywordflow">if</span> ( $rim ) {
<a name="l00106"></a>00106         <span class="keywordflow">if</span> ( $rim eq ref $self ) {
<a name="l00107"></a>00107         $im = <a class="code" href="classComplex1.html#a5d2b6e9c6a6e480809f2005d17f90af9">Im</a>($im);
<a name="l00108"></a>00108         } <span class="keywordflow">else</span> {
<a name="l00109"></a>00109         <a class="code" href="classComplex1.html#a4cbce7a9a2cc78ef7949bbb2a8201614">_cannot_make</a>(<span class="stringliteral">&quot;imaginary part&quot;</span>, $rim);
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111     }
<a name="l00112"></a>00112     $self-&gt;{<span class="stringliteral">&#39;cartesian&#39;</span>} = [ $re, $im ];
<a name="l00113"></a>00113     $self-&gt;{c_dirty} = 0;
<a name="l00114"></a>00114     $self-&gt;{p_dirty} = 1;
<a name="l00115"></a>00115     $self-&gt;display_format(<span class="stringliteral">&#39;cartesian&#39;</span>);
<a name="l00116"></a>00116     <span class="keywordflow">return</span> $self;
<a name="l00117"></a>00117 }
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="preprocessor">#</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span><span class="preprocessor"># -&gt;emake</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="preprocessor"># Create a new complex number (exponential form)</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span>sub emake {
<a name="l00125"></a>00125     my $self = bless {}, shift;
<a name="l00126"></a>00126     my ($rho, $theta) = @_;
<a name="l00127"></a>00127     my $rrh = ref $rho;
<a name="l00128"></a>00128     <span class="keywordflow">if</span> ( $rrh ) {
<a name="l00129"></a>00129         <span class="keywordflow">if</span> ( $rrh eq ref $self ) {
<a name="l00130"></a>00130         $rho = rho($rho);
<a name="l00131"></a>00131         } <span class="keywordflow">else</span> {
<a name="l00132"></a>00132         _cannot_make(<span class="stringliteral">&quot;rho&quot;</span>, $rrh);
<a name="l00133"></a>00133         }
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135     my $rth = ref $theta;
<a name="l00136"></a>00136     <span class="keywordflow">if</span> ( $rth ) {
<a name="l00137"></a>00137         <span class="keywordflow">if</span> ( $rth eq ref $self ) {
<a name="l00138"></a>00138         $theta = theta($theta);
<a name="l00139"></a>00139         } <span class="keywordflow">else</span> {
<a name="l00140"></a>00140         _cannot_make(<span class="stringliteral">&quot;theta&quot;</span>, $rth);
<a name="l00141"></a>00141         }
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143     <span class="keywordflow">if</span> ($rho &lt; 0) {
<a name="l00144"></a>00144         $rho   = -$rho;
<a name="l00145"></a>00145         $theta = ($theta &lt;= 0) ? $theta + pi() : $theta - pi();
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147     $self-&gt;{<span class="stringliteral">&#39;polar&#39;</span>} = [$rho, $theta];
<a name="l00148"></a>00148     $self-&gt;{p_dirty} = 0;
<a name="l00149"></a>00149     $self-&gt;{c_dirty} = 1;
<a name="l00150"></a>00150     $self-&gt;display_format(<span class="stringliteral">&#39;polar&#39;</span>);
<a name="l00151"></a>00151     <span class="keywordflow">return</span> $self;
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 sub <span class="keyword">new</span> { &amp;make }       # For backward compatibility only.
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 #
<a name="l00157"></a>00157 <span class="preprocessor"># cplx</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span><span class="preprocessor"># Creates a complex number from a (re, im) tuple.</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span><span class="preprocessor"># This avoids the burden of writing Math::Complex-&gt;make(re, im).</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span>sub cplx {
<a name="l00163"></a>00163     my ($re, $im) = @_;
<a name="l00164"></a>00164     <span class="keywordflow">return</span> $package-&gt;make(defined $re ? $re : 0, defined $im ? $im : 0);
<a name="l00165"></a>00165 }
<a name="l00166"></a>00166 <span class="preprocessor"># cplx adn cplxe changed by MEG</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span><span class="preprocessor"># cplxe</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span><span class="preprocessor"># Creates a complex number from a (rho, theta) tuple.</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span><span class="preprocessor"># This avoids the burden of writing Math::Complex-&gt;emake(rho, theta).</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span>sub cplxe {
<a name="l00174"></a>00174     my ($rho, $theta) = @_;
<a name="l00175"></a>00175     <span class="keywordflow">return</span> $package-&gt;emake(defined $rho ? $rho : 0, defined $theta ? $theta : 0);
<a name="l00176"></a>00176 }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="preprocessor">#</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="preprocessor"># pi</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span><span class="preprocessor"># The number defined as pi = 180 degrees</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span>use constant pi =&gt; 4 * CORE::atan2(1, 1);
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="preprocessor">#</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span><span class="preprocessor"># pit2</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span><span class="preprocessor"># The full circle</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span>use constant pit2 =&gt; 2 * pi;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="preprocessor">#</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span><span class="preprocessor"># pip2</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span><span class="preprocessor"># The quarter circle</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>use constant pip2 =&gt; pi / 2;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="preprocessor">#</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span><span class="preprocessor"># deg1</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span><span class="preprocessor"># One degree in radians, used in stringify_polar.</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span>
<a name="l00205"></a>00205 use constant deg1 =&gt; pi / 180;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="preprocessor">#</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span><span class="preprocessor"># uplog10</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00210"></a>00210 <span class="preprocessor"></span><span class="preprocessor"># Used in log10().</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span>use constant uplog10 =&gt; 1 / CORE::log(10);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 <span class="preprocessor">#</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span><span class="preprocessor"># i</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span><span class="preprocessor"># The number defined as i*i = -1;</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>sub i () {
<a name="l00220"></a>00220         <span class="keywordflow">return</span> $i <span class="keywordflow">if</span> ($i);
<a name="l00221"></a>00221     $i = bless {};
<a name="l00222"></a>00222     $i-&gt;{<span class="stringliteral">&#39;cartesian&#39;</span>} = [0, 1];
<a name="l00223"></a>00223     $i-&gt;{<span class="stringliteral">&#39;polar&#39;</span>}     = [1, pip2];
<a name="l00224"></a>00224     $i-&gt;{c_dirty} = 0;
<a name="l00225"></a>00225     $i-&gt;{p_dirty} = 0;
<a name="l00226"></a>00226     <span class="keywordflow">return</span> $i;
<a name="l00227"></a>00227 }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="preprocessor">#</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span><span class="preprocessor"># Attribute access/set routines</span>
<a name="l00231"></a>00231 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span>
<a name="l00233"></a>00233 sub cartesian {$_[0]-&gt;{c_dirty} ?
<a name="l00234"></a>00234            $_[0]-&gt;update_cartesian : $_[0]-&gt;{<span class="stringliteral">&#39;cartesian&#39;</span>}}
<a name="l00235"></a>00235 sub polar     {$_[0]-&gt;{p_dirty} ?
<a name="l00236"></a>00236            $_[0]-&gt;update_polar : $_[0]-&gt;{<span class="stringliteral">&#39;polar&#39;</span>}}
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 sub set_cartesian { $_[0]-&gt;{p_dirty}++; $_[0]-&gt;{<span class="stringliteral">&#39;cartesian&#39;</span>} = $_[1] }
<a name="l00239"></a>00239 sub set_polar     { $_[0]-&gt;{c_dirty}++; $_[0]-&gt;{<span class="stringliteral">&#39;polar&#39;</span>} = $_[1] }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="preprocessor">#</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span><span class="preprocessor"># -&gt;update_cartesian</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span><span class="preprocessor"># Recompute and return the cartesian form, given accurate polar form.</span>
<a name="l00245"></a>00245 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span>sub update_cartesian {
<a name="l00247"></a>00247     my $self = shift;
<a name="l00248"></a>00248     my ($r, $t) = @{$self-&gt;{<span class="stringliteral">&#39;polar&#39;</span>}};
<a name="l00249"></a>00249     $self-&gt;{c_dirty} = 0;
<a name="l00250"></a>00250     <span class="keywordflow">return</span> $self-&gt;{<span class="stringliteral">&#39;cartesian&#39;</span>} = [$r * CORE::cos($t), $r * CORE::sin($t)];
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 <span class="preprocessor">#</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span><span class="preprocessor"># -&gt;update_polar</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00257"></a>00257 <span class="preprocessor"></span><span class="preprocessor"># Recompute and return the polar form, given accurate cartesian form.</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00259"></a>00259 <span class="preprocessor"></span>sub update_polar {
<a name="l00260"></a>00260     my $self = shift;
<a name="l00261"></a>00261     my ($x, $y) = @{$self-&gt;{<span class="stringliteral">&#39;cartesian&#39;</span>}};
<a name="l00262"></a>00262     $self-&gt;{p_dirty} = 0;
<a name="l00263"></a>00263     <span class="keywordflow">return</span> $self-&gt;{<span class="stringliteral">&#39;polar&#39;</span>} = [0, 0] <span class="keywordflow">if</span> $x == 0 &amp;&amp; $y == 0;
<a name="l00264"></a>00264     <span class="keywordflow">return</span> $self-&gt;{<span class="stringliteral">&#39;polar&#39;</span>} = [CORE::sqrt($x*$x + $y*$y), CORE::atan2($y, $x)];
<a name="l00265"></a>00265 }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="preprocessor">#</span>
<a name="l00268"></a>00268 <span class="preprocessor"></span><span class="preprocessor"># (plus)</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00270"></a>00270 <span class="preprocessor"></span><span class="preprocessor"># Computes z1+z2.</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00272"></a>00272 <span class="preprocessor"></span>sub plus {
<a name="l00273"></a>00273     my ($z1, $z2, $regular) = @_;
<a name="l00274"></a>00274     my ($re1, $im1) = @{$z1-&gt;cartesian};
<a name="l00275"></a>00275     $z2 = cplx($z2) unless ref $z2;
<a name="l00276"></a>00276     my ($re2, $im2) = ref $z2 ? @{$z2-&gt;cartesian} : ($z2, 0);
<a name="l00277"></a>00277     unless (defined $regular) {
<a name="l00278"></a>00278         $z1-&gt;set_cartesian([$re1 + $re2, $im1 + $im2]);
<a name="l00279"></a>00279         <span class="keywordflow">return</span> $z1;
<a name="l00280"></a>00280     }
<a name="l00281"></a>00281     <span class="keywordflow">return</span> (ref $z1)-&gt;make($re1 + $re2, $im1 + $im2);
<a name="l00282"></a>00282 }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 <span class="preprocessor">#</span>
<a name="l00285"></a>00285 <span class="preprocessor"></span><span class="preprocessor"># (minus)</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span><span class="preprocessor"># Computes z1-z2.</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span>sub minus {
<a name="l00290"></a>00290     my ($z1, $z2, $inverted) = @_;
<a name="l00291"></a>00291     my ($re1, $im1) = @{$z1-&gt;cartesian};
<a name="l00292"></a>00292     $z2 = cplx($z2) unless ref $z2;
<a name="l00293"></a>00293     my ($re2, $im2) = @{$z2-&gt;cartesian};
<a name="l00294"></a>00294     unless (defined $inverted) {
<a name="l00295"></a>00295         $z1-&gt;set_cartesian([$re1 - $re2, $im1 - $im2]);
<a name="l00296"></a>00296         <span class="keywordflow">return</span> $z1;
<a name="l00297"></a>00297     }
<a name="l00298"></a>00298     
<a name="l00299"></a>00299      <span class="keywordflow">return</span> ( $inverted) ?
<a name="l00300"></a>00300         (ref $z1)-&gt;make($re2 - $re1, $im2 - $im1) : 
<a name="l00301"></a>00301         (ref $z1)-&gt;make($re1 - $re2, $im1 - $im2);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="preprocessor">#</span>
<a name="l00306"></a>00306 <span class="preprocessor"></span><span class="preprocessor"># (multiply)</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00308"></a>00308 <span class="preprocessor"></span><span class="preprocessor"># Computes z1*z2.</span>
<a name="l00309"></a>00309 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00310"></a>00310 <span class="preprocessor"></span>sub multiply {
<a name="l00311"></a>00311         my ($z1, $z2, $regular) = @_;
<a name="l00312"></a>00312     <span class="keywordflow">if</span> ($z1-&gt;{p_dirty} == 0 and ref $z2 and $z2-&gt;{p_dirty} == 0) {
<a name="l00313"></a>00313 <span class="preprocessor">        # if both polar better use polar to avoid rounding errors</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>        my ($r1, $t1) = @{$z1-&gt;polar};
<a name="l00315"></a>00315         my ($r2, $t2) = @{$z2-&gt;polar};
<a name="l00316"></a>00316         my $t = $t1 + $t2;
<a name="l00317"></a>00317         <span class="keywordflow">if</span>    ($t &gt;   pi()) { $t -= pit2 }
<a name="l00318"></a>00318         elsif ($t &lt;= -pi()) { $t += pit2 }
<a name="l00319"></a>00319         unless (defined $regular) {
<a name="l00320"></a>00320         $z1-&gt;set_polar([$r1 * $r2, $t]);
<a name="l00321"></a>00321         <span class="keywordflow">return</span> $z1;
<a name="l00322"></a>00322         }
<a name="l00323"></a>00323         <span class="keywordflow">return</span> (ref $z1)-&gt;emake($r1 * $r2, $t);
<a name="l00324"></a>00324     } <span class="keywordflow">else</span> {
<a name="l00325"></a>00325         my ($x1, $y1) = @{$z1-&gt;cartesian};
<a name="l00326"></a>00326         <span class="keywordflow">if</span> (ref $z2) {
<a name="l00327"></a>00327         my ($x2, $y2) = @{$z2-&gt;cartesian};
<a name="l00328"></a>00328         <span class="keywordflow">return</span> (ref $z1)-&gt;make($x1*$x2-$y1*$y2, $x1*$y2+$y1*$x2);
<a name="l00329"></a>00329         } <span class="keywordflow">else</span> {
<a name="l00330"></a>00330         <span class="keywordflow">return</span> (ref $z1)-&gt;make($x1*$z2, $y1*$z2);
<a name="l00331"></a>00331         }
<a name="l00332"></a>00332     }
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="preprocessor">#</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span><span class="preprocessor"># _divbyzero</span>
<a name="l00337"></a>00337 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00338"></a>00338 <span class="preprocessor"></span><span class="preprocessor"># Die on division by zero.</span>
<a name="l00339"></a>00339 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00340"></a>00340 <span class="preprocessor"></span>sub _divbyzero {
<a name="l00341"></a>00341     my $mess = <span class="stringliteral">&quot;$_[0]: Division by zero.\n&quot;</span>;
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     <span class="keywordflow">if</span> (defined $_[1]) {
<a name="l00344"></a>00344     $mess .= <span class="stringliteral">&quot;(Because in the definition of $_[0], the divisor &quot;</span>;
<a name="l00345"></a>00345     $mess .= <span class="stringliteral">&quot;$_[1] &quot;</span> unless ($_[1] eq <span class="charliteral">&#39;0&#39;</span>);
<a name="l00346"></a>00346     $mess .= <span class="stringliteral">&quot;is 0)\n&quot;</span>;
<a name="l00347"></a>00347     }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     my @up = caller(1);
<a name="l00350"></a>00350 
<a name="l00351"></a>00351     $mess .= <span class="stringliteral">&quot;Died at $up[1] line $up[2].\n&quot;</span>;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353     die $mess;
<a name="l00354"></a>00354 }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="preprocessor">#</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span><span class="preprocessor"># (divide)</span>
<a name="l00358"></a>00358 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span><span class="preprocessor"># Computes z1/z2.</span>
<a name="l00360"></a>00360 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>sub divide {
<a name="l00362"></a>00362     my ($z1, $z2, $inverted) = @_;
<a name="l00363"></a>00363     <span class="keywordflow">if</span> ($z1-&gt;{p_dirty} == 0 and ref $z2 and $z2-&gt;{p_dirty} == 0) {
<a name="l00364"></a>00364 <span class="preprocessor">        # if both polar better use polar to avoid rounding errors</span>
<a name="l00365"></a>00365 <span class="preprocessor"></span>        my ($r1, $t1) = @{$z1-&gt;polar};
<a name="l00366"></a>00366         my ($r2, $t2) = @{$z2-&gt;polar};
<a name="l00367"></a>00367         my $t;
<a name="l00368"></a>00368         <span class="keywordflow">if</span> ($inverted) {
<a name="l00369"></a>00369         _divbyzero <span class="stringliteral">&quot;$z2/0&quot;</span> <span class="keywordflow">if</span> ($r1 == 0);
<a name="l00370"></a>00370         $t = $t2 - $t1;
<a name="l00371"></a>00371         <span class="keywordflow">if</span>    ($t &gt;   pi()) { $t -= pit2 }
<a name="l00372"></a>00372         elsif ($t &lt;= -pi()) { $t += pit2 }
<a name="l00373"></a>00373         <span class="keywordflow">return</span> (ref $z1)-&gt;emake($r2 / $r1, $t);
<a name="l00374"></a>00374         } <span class="keywordflow">else</span> {
<a name="l00375"></a>00375         _divbyzero <span class="stringliteral">&quot;$z1/0&quot;</span> <span class="keywordflow">if</span> ($r2 == 0);
<a name="l00376"></a>00376         $t = $t1 - $t2;
<a name="l00377"></a>00377         <span class="keywordflow">if</span>    ($t &gt;   pi()) { $t -= pit2 }
<a name="l00378"></a>00378         elsif ($t &lt;= -pi()) { $t += pit2 }
<a name="l00379"></a>00379         <span class="keywordflow">return</span> (ref $z1)-&gt;emake($r1 / $r2, $t);
<a name="l00380"></a>00380         }
<a name="l00381"></a>00381     } <span class="keywordflow">else</span> {
<a name="l00382"></a>00382         my ($d, $x2, $y2);
<a name="l00383"></a>00383         <span class="keywordflow">if</span> ($inverted) {
<a name="l00384"></a>00384         ($x2, $y2) = @{$z1-&gt;cartesian};
<a name="l00385"></a>00385         $d = $x2*$x2 + $y2*$y2;
<a name="l00386"></a>00386         _divbyzero <span class="stringliteral">&quot;$z2/0&quot;</span> <span class="keywordflow">if</span> $d == 0;
<a name="l00387"></a>00387         <span class="keywordflow">return</span> (ref $z1)-&gt;make(($x2*$z2)/$d, -($y2*$z2)/$d);
<a name="l00388"></a>00388         } <span class="keywordflow">else</span> {
<a name="l00389"></a>00389         my ($x1, $y1) = @{$z1-&gt;cartesian};
<a name="l00390"></a>00390         <span class="keywordflow">if</span> (ref $z2) {
<a name="l00391"></a>00391             ($x2, $y2) = @{$z2-&gt;cartesian};
<a name="l00392"></a>00392             $d = $x2*$x2 + $y2*$y2;
<a name="l00393"></a>00393             _divbyzero <span class="stringliteral">&quot;$z1/0&quot;</span> <span class="keywordflow">if</span> $d == 0;
<a name="l00394"></a>00394             my $u = ($x1*$x2 + $y1*$y2)/$d;
<a name="l00395"></a>00395             my $v = ($y1*$x2 - $x1*$y2)/$d;
<a name="l00396"></a>00396             <span class="keywordflow">return</span> (ref $z1)-&gt;make($u, $v);
<a name="l00397"></a>00397         } <span class="keywordflow">else</span> {
<a name="l00398"></a>00398             _divbyzero <span class="stringliteral">&quot;$z1/0&quot;</span> <span class="keywordflow">if</span> $z2 == 0;
<a name="l00399"></a>00399             <span class="keywordflow">return</span> (ref $z1)-&gt;make($x1/$z2, $y1/$z2);
<a name="l00400"></a>00400         }
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402     }
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="preprocessor">#</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span><span class="preprocessor"># (power)</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00408"></a>00408 <span class="preprocessor"></span><span class="preprocessor"># Computes z1**z2 = exp(z2 * log z1)).</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00410"></a>00410 <span class="preprocessor"></span>sub power {
<a name="l00411"></a>00411     my ($z1, $z2, $inverted) = @_;
<a name="l00412"></a>00412     <span class="keywordflow">if</span> ($inverted) {
<a name="l00413"></a>00413         <span class="keywordflow">return</span> 1 <span class="keywordflow">if</span> $z1 == 0 || $z2 == 1;
<a name="l00414"></a>00414         <span class="keywordflow">return</span> 0 <span class="keywordflow">if</span> $z2 == 0 &amp;&amp; Re($z1) &gt; 0;
<a name="l00415"></a>00415     } <span class="keywordflow">else</span> {
<a name="l00416"></a>00416         <span class="keywordflow">return</span> 1 <span class="keywordflow">if</span> $z2 == 0 || $z1 == 1;
<a name="l00417"></a>00417         <span class="keywordflow">return</span> 0 <span class="keywordflow">if</span> $z1 == 0 &amp;&amp; Re($z2) &gt; 0;
<a name="l00418"></a>00418     }
<a name="l00419"></a>00419     my $w = $inverted ? CORE::exp($z1 * CORE::log($z2))
<a name="l00420"></a>00420                       : CORE::exp($z2 * CORE::log($z1));
<a name="l00421"></a>00421 <span class="preprocessor">    # If both arguments cartesian, return cartesian, else polar.</span>
<a name="l00422"></a>00422 <span class="preprocessor"></span>    <span class="keywordflow">return</span> $z1-&gt;{c_dirty} == 0 &amp;&amp;
<a name="l00423"></a>00423            (not ref $z2 or $z2-&gt;{c_dirty} == 0) ?
<a name="l00424"></a>00424            cplx(@{$w-&gt;cartesian}) : $w;
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="preprocessor">#</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span><span class="preprocessor"># (spaceship)</span>
<a name="l00429"></a>00429 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00430"></a>00430 <span class="preprocessor"></span><span class="preprocessor"># Computes z1 &lt;=&gt; z2.</span>
<a name="l00431"></a>00431 <span class="preprocessor"></span><span class="preprocessor"># Sorts on the real part first, then on the imaginary part. Thus 2-4i &lt; 3+8i.</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00433"></a>00433 <span class="preprocessor"></span>sub spaceship {
<a name="l00434"></a>00434     my ($z1, $z2, $inverted) = @_;
<a name="l00435"></a>00435     my ($re1, $im1) = ref $z1 ? @{$z1-&gt;cartesian} : ($z1, 0);
<a name="l00436"></a>00436     my ($re2, $im2) = ref $z2 ? @{$z2-&gt;cartesian} : ($z2, 0);
<a name="l00437"></a>00437     my $sgn = $inverted ? -1 : 1;
<a name="l00438"></a>00438     <span class="keywordflow">return</span> $sgn * ($re1 &lt;=&gt; $re2) <span class="keywordflow">if</span> $re1 != $re2;
<a name="l00439"></a>00439     <span class="keywordflow">return</span> $sgn * ($im1 &lt;=&gt; $im2);
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="preprocessor">#</span>
<a name="l00443"></a>00443 <span class="preprocessor"></span><span class="preprocessor"># (negate)</span>
<a name="l00444"></a>00444 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00445"></a>00445 <span class="preprocessor"></span><span class="preprocessor"># Computes -z.</span>
<a name="l00446"></a>00446 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span>sub negate {
<a name="l00448"></a>00448     my ($z) = @_;
<a name="l00449"></a>00449     <span class="keywordflow">if</span> ($z-&gt;{c_dirty}) {
<a name="l00450"></a>00450         my ($r, $t) = @{$z-&gt;polar};
<a name="l00451"></a>00451         $t = ($t &lt;= 0) ? $t + pi : $t - pi;
<a name="l00452"></a>00452         <span class="keywordflow">return</span> (ref $z)-&gt;emake($r, $t);
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454     my ($re, $im) = @{$z-&gt;cartesian};
<a name="l00455"></a>00455     <span class="keywordflow">return</span> (ref $z)-&gt;make(-$re, -$im);
<a name="l00456"></a>00456 }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 <span class="preprocessor">#</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span><span class="preprocessor"># (conjugate)</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00461"></a>00461 <span class="preprocessor"></span><span class="preprocessor"># Compute complex&#39;s conjugate.</span>
<a name="l00462"></a>00462 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>sub conjugate {
<a name="l00464"></a>00464     my ($z) = @_;
<a name="l00465"></a>00465     <span class="keywordflow">if</span> ($z-&gt;{c_dirty}) {
<a name="l00466"></a>00466         my ($r, $t) = @{$z-&gt;polar};
<a name="l00467"></a>00467         <span class="keywordflow">return</span> (ref $z)-&gt;emake($r, -$t);
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469     my ($re, $im) = @{$z-&gt;cartesian};
<a name="l00470"></a>00470     <span class="keywordflow">return</span> (ref $z)-&gt;make($re, -$im);
<a name="l00471"></a>00471 }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="preprocessor">#</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span><span class="preprocessor"># (abs)</span>
<a name="l00475"></a>00475 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00476"></a>00476 <span class="preprocessor"></span><span class="preprocessor"># Compute or set complex&#39;s norm (rho).</span>
<a name="l00477"></a>00477 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span>sub abs {
<a name="l00479"></a>00479     my ($z, $rho) = @_;
<a name="l00480"></a>00480     <span class="keywordflow">return</span> $z unless ref $z;
<a name="l00481"></a>00481     <span class="keywordflow">if</span> (defined $rho) {
<a name="l00482"></a>00482         $z-&gt;{<span class="stringliteral">&#39;polar&#39;</span>} = [ $rho, ${$z-&gt;polar}[1] ];
<a name="l00483"></a>00483         $z-&gt;{p_dirty} = 0;
<a name="l00484"></a>00484         $z-&gt;{c_dirty} = 1;
<a name="l00485"></a>00485         <span class="keywordflow">return</span> $rho;
<a name="l00486"></a>00486     } <span class="keywordflow">else</span> {
<a name="l00487"></a>00487         <span class="keywordflow">return</span> ${$z-&gt;polar}[0];
<a name="l00488"></a>00488     }
<a name="l00489"></a>00489 }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 sub _theta {
<a name="l00492"></a>00492     my $theta = $_[0];
<a name="l00493"></a>00493 
<a name="l00494"></a>00494     <span class="keywordflow">if</span>    ($$theta &gt;   pi()) { $$theta -= pit2 }
<a name="l00495"></a>00495     elsif ($$theta &lt;= -pi()) { $$theta += pit2 }
<a name="l00496"></a>00496 }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 <span class="preprocessor">#</span>
<a name="l00499"></a>00499 <span class="preprocessor"></span><span class="preprocessor"># arg</span>
<a name="l00500"></a>00500 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00501"></a>00501 <span class="preprocessor"></span><span class="preprocessor"># Compute or set complex&#39;s argument (theta).</span>
<a name="l00502"></a>00502 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00503"></a>00503 <span class="preprocessor"></span>sub arg {
<a name="l00504"></a>00504     my ($z, $theta) = @_;
<a name="l00505"></a>00505     <span class="keywordflow">return</span> $z unless ref $z;
<a name="l00506"></a>00506     <span class="keywordflow">if</span> (defined $theta) {
<a name="l00507"></a>00507         _theta(\$theta);
<a name="l00508"></a>00508         $z-&gt;{<span class="stringliteral">&#39;polar&#39;</span>} = [ ${$z-&gt;polar}[0], $theta ];
<a name="l00509"></a>00509         $z-&gt;{p_dirty} = 0;
<a name="l00510"></a>00510         $z-&gt;{c_dirty} = 1;
<a name="l00511"></a>00511     } <span class="keywordflow">else</span> {
<a name="l00512"></a>00512         $theta = ${$z-&gt;polar}[1];
<a name="l00513"></a>00513         _theta(\$theta);
<a name="l00514"></a>00514     }
<a name="l00515"></a>00515     <span class="keywordflow">return</span> $theta;
<a name="l00516"></a>00516 }
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 <span class="preprocessor">#</span>
<a name="l00519"></a>00519 <span class="preprocessor"></span><span class="preprocessor"># (sqrt)</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00521"></a>00521 <span class="preprocessor"></span><span class="preprocessor"># Compute sqrt(z).</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span><span class="preprocessor"># It is quite tempting to use wantarray here so that in list context</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span><span class="preprocessor"># sqrt() would return the two solutions.  This, however, would</span>
<a name="l00525"></a>00525 <span class="preprocessor"></span><span class="preprocessor"># break things like</span>
<a name="l00526"></a>00526 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00527"></a>00527 <span class="preprocessor"></span><span class="preprocessor">#   print &quot;sqrt(z) = &quot;, sqrt($z), &quot;\n&quot;;</span>
<a name="l00528"></a>00528 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00529"></a>00529 <span class="preprocessor"></span><span class="preprocessor"># The two values would be printed side by side without no intervening</span>
<a name="l00530"></a>00530 <span class="preprocessor"></span><span class="preprocessor"># whitespace, quite confusing.</span>
<a name="l00531"></a>00531 <span class="preprocessor"></span><span class="preprocessor"># Therefore if you want the two solutions use the root().</span>
<a name="l00532"></a>00532 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00533"></a>00533 <span class="preprocessor"></span>sub sqrt {
<a name="l00534"></a>00534     my ($z) = @_;
<a name="l00535"></a>00535     my ($re, $im) = ref $z ? @{$z-&gt;cartesian} : ($z, 0);
<a name="l00536"></a>00536     <span class="keywordflow">return</span> $re &lt; 0 ? cplx(0, CORE::sqrt(-$re)) : CORE::sqrt($re) if $im == 0;
<a name="l00537"></a>00537     my ($r, $t) = @{$z-&gt;polar};
<a name="l00538"></a>00538     <span class="keywordflow">return</span> (ref $z)-&gt;emake(CORE::sqrt($r), $t/2);
<a name="l00539"></a>00539 }
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 <span class="preprocessor">#</span>
<a name="l00542"></a>00542 <span class="preprocessor"></span><span class="preprocessor"># cbrt</span>
<a name="l00543"></a>00543 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00544"></a>00544 <span class="preprocessor"></span><span class="preprocessor"># Compute cbrt(z) (cubic root).</span>
<a name="l00545"></a>00545 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00546"></a>00546 <span class="preprocessor"></span><span class="preprocessor"># Why are we not returning three values?  The same answer as for sqrt().</span>
<a name="l00547"></a>00547 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00548"></a>00548 <span class="preprocessor"></span>sub cbrt {
<a name="l00549"></a>00549     my ($z) = @_;
<a name="l00550"></a>00550     <span class="keywordflow">return</span> $z &lt; 0 ? -CORE::exp(CORE::log(-$z)/3) : ($z &gt; 0 ? CORE::exp(CORE::log($z)/3): 0)
<a name="l00551"></a>00551         unless ref $z;
<a name="l00552"></a>00552     my ($r, $t) = @{$z-&gt;polar};
<a name="l00553"></a>00553     <span class="keywordflow">return</span> (ref $z)-&gt;emake(CORE::exp(CORE::log($r)/3), $t/3);
<a name="l00554"></a>00554 }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="preprocessor">#</span>
<a name="l00557"></a>00557 <span class="preprocessor"></span><span class="preprocessor"># _rootbad</span>
<a name="l00558"></a>00558 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00559"></a>00559 <span class="preprocessor"></span><span class="preprocessor"># Die on bad root.</span>
<a name="l00560"></a>00560 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00561"></a>00561 <span class="preprocessor"></span>sub _rootbad {
<a name="l00562"></a>00562     my $mess = <span class="stringliteral">&quot;Root $_[0] not defined, root must be positive integer.\n&quot;</span>;
<a name="l00563"></a>00563 
<a name="l00564"></a>00564     my @up = caller(1);
<a name="l00565"></a>00565 
<a name="l00566"></a>00566     $mess .= <span class="stringliteral">&quot;Died at $up[1] line $up[2].\n&quot;</span>;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     die $mess;
<a name="l00569"></a>00569 }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 <span class="preprocessor">#</span>
<a name="l00572"></a>00572 <span class="preprocessor"></span><span class="preprocessor"># root</span>
<a name="l00573"></a>00573 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00574"></a>00574 <span class="preprocessor"></span><span class="preprocessor"># Computes all nth root for z, returning an array whose size is n.</span>
<a name="l00575"></a>00575 <span class="preprocessor"></span><span class="preprocessor"># `n&#39; must be a positive integer.</span>
<a name="l00576"></a>00576 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00577"></a>00577 <span class="preprocessor"></span><span class="preprocessor"># The roots are given by (for k = 0..n-1):</span>
<a name="l00578"></a>00578 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00579"></a>00579 <span class="preprocessor"></span><span class="preprocessor"># z^(1/n) = r^(1/n) (cos ((t+2 k pi)/n) + i sin ((t+2 k pi)/n))</span>
<a name="l00580"></a>00580 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00581"></a>00581 <span class="preprocessor"></span>sub root {
<a name="l00582"></a>00582     my ($z, $n) = @_;
<a name="l00583"></a>00583     _rootbad($n) if ($n &lt; 1 or <span class="keywordtype">int</span>($n) != $n);
<a name="l00584"></a>00584     my ($r, $t) = ref $z ? @{$z-&gt;polar} : (CORE::abs($z), $z &gt;= 0 ? 0 : pi);
<a name="l00585"></a>00585     my @root;
<a name="l00586"></a>00586     my $k;
<a name="l00587"></a>00587     my $theta_inc = pit2 / $n;
<a name="l00588"></a>00588     my $rho = $r ** (1/$n);
<a name="l00589"></a>00589     my $theta;
<a name="l00590"></a>00590     my $cartesian = ref $z &amp;&amp; $z-&gt;{c_dirty} == 0;
<a name="l00591"></a>00591     <span class="keywordflow">for</span> ($k = 0, $theta = $t / $n; $k &lt; $n; $k++, $theta += $theta_inc) {
<a name="l00592"></a>00592         my $w = cplxe($rho, $theta);
<a name="l00593"></a>00593 <span class="preprocessor">        # Yes, $cartesian is loop invariant.</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span>        push @root, $cartesian ? cplx(@{$w-&gt;cartesian}) : $w;
<a name="l00595"></a>00595     }
<a name="l00596"></a>00596     <span class="keywordflow">return</span> @root;
<a name="l00597"></a>00597 }
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 <span class="preprocessor">#</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span><span class="preprocessor"># Re</span>
<a name="l00601"></a>00601 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00602"></a>00602 <span class="preprocessor"></span><span class="preprocessor"># Return or set Re(z).</span>
<a name="l00603"></a>00603 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00604"></a>00604 <span class="preprocessor"></span>sub Re {
<a name="l00605"></a>00605     my ($z, $Re) = @_;
<a name="l00606"></a>00606     <span class="keywordflow">return</span> $z unless ref $z;
<a name="l00607"></a>00607     <span class="keywordflow">if</span> (defined $Re) {
<a name="l00608"></a>00608         $z-&gt;{<span class="stringliteral">&#39;cartesian&#39;</span>} = [ $Re, ${$z-&gt;cartesian}[1] ];
<a name="l00609"></a>00609         $z-&gt;{c_dirty} = 0;
<a name="l00610"></a>00610         $z-&gt;{p_dirty} = 1;
<a name="l00611"></a>00611     } <span class="keywordflow">else</span> {
<a name="l00612"></a>00612         <span class="keywordflow">return</span> ${$z-&gt;cartesian}[0];
<a name="l00613"></a>00613     }
<a name="l00614"></a>00614 }
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 <span class="preprocessor">#</span>
<a name="l00617"></a>00617 <span class="preprocessor"></span><span class="preprocessor"># Im</span>
<a name="l00618"></a>00618 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00619"></a>00619 <span class="preprocessor"></span><span class="preprocessor"># Return or set Im(z).</span>
<a name="l00620"></a>00620 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00621"></a>00621 <span class="preprocessor"></span>sub Im {
<a name="l00622"></a>00622     my ($z, $Im) = @_;
<a name="l00623"></a>00623     <span class="keywordflow">return</span> $z unless ref $z;
<a name="l00624"></a>00624     <span class="keywordflow">if</span> (defined $Im) {
<a name="l00625"></a>00625         $z-&gt;{<span class="stringliteral">&#39;cartesian&#39;</span>} = [ ${$z-&gt;cartesian}[0], $Im ];
<a name="l00626"></a>00626         $z-&gt;{c_dirty} = 0;
<a name="l00627"></a>00627         $z-&gt;{p_dirty} = 1;
<a name="l00628"></a>00628     } <span class="keywordflow">else</span> {
<a name="l00629"></a>00629         <span class="keywordflow">return</span> ${$z-&gt;cartesian}[1];
<a name="l00630"></a>00630     }
<a name="l00631"></a>00631 }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 <span class="preprocessor">#</span>
<a name="l00634"></a>00634 <span class="preprocessor"></span><span class="preprocessor"># rho</span>
<a name="l00635"></a>00635 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00636"></a>00636 <span class="preprocessor"></span><span class="preprocessor"># Return or set rho(w).</span>
<a name="l00637"></a>00637 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00638"></a>00638 <span class="preprocessor"></span>sub rho {
<a name="l00639"></a>00639     <a class="code" href="classComplex1.html#a2441c6180fe0532fa21c7cfa3875c004">Complex1::abs</a>(@_);
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 <span class="preprocessor">#</span>
<a name="l00643"></a>00643 <span class="preprocessor"></span><span class="preprocessor"># theta</span>
<a name="l00644"></a>00644 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00645"></a>00645 <span class="preprocessor"></span><span class="preprocessor"># Return or set theta(w).</span>
<a name="l00646"></a>00646 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00647"></a>00647 <span class="preprocessor"></span>sub theta {
<a name="l00648"></a>00648     <a class="code" href="classComplex1.html#a991040a76389558c2a0a57a32c8b64aa">Complex1::arg</a>(@_);
<a name="l00649"></a>00649 }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 <span class="preprocessor">#</span>
<a name="l00652"></a>00652 <span class="preprocessor"></span><span class="preprocessor"># (exp)</span>
<a name="l00653"></a>00653 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00654"></a>00654 <span class="preprocessor"></span><span class="preprocessor"># Computes exp(z).</span>
<a name="l00655"></a>00655 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span>sub exp {
<a name="l00657"></a>00657     my ($z) = @_;
<a name="l00658"></a>00658     my ($x, $y) = @{$z-&gt;cartesian};
<a name="l00659"></a>00659     <span class="keywordflow">return</span> (ref $z)-&gt;emake(CORE::exp($x), $y);
<a name="l00660"></a>00660 }
<a name="l00661"></a>00661 
<a name="l00662"></a>00662 <span class="preprocessor">#</span>
<a name="l00663"></a>00663 <span class="preprocessor"></span><span class="preprocessor"># _logofzero</span>
<a name="l00664"></a>00664 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00665"></a>00665 <span class="preprocessor"></span><span class="preprocessor"># Die on logarithm of zero.</span>
<a name="l00666"></a>00666 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00667"></a>00667 <span class="preprocessor"></span>sub _logofzero {
<a name="l00668"></a>00668     my $mess = <span class="stringliteral">&quot;$_[0]: Logarithm of zero.\n&quot;</span>;
<a name="l00669"></a>00669 
<a name="l00670"></a><a class="code" href="classComplex1.html">00670</a>     <span class="keywordflow">if</span> (defined $_[1]) {
<a name="l00671"></a>00671     $mess .= <span class="stringliteral">&quot;(Because in the definition of $_[0], the argument &quot;</span>;
<a name="l00672"></a>00672     $mess .= <span class="stringliteral">&quot;$_[1] &quot;</span> unless ($_[1] eq <span class="charliteral">&#39;0&#39;</span>);
<a name="l00673"></a>00673     $mess .= <span class="stringliteral">&quot;is 0)\n&quot;</span>;
<a name="l00674"></a>00674     }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676     my @up = caller(1);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     $mess .= <span class="stringliteral">&quot;Died at $up[1] line $up[2].\n&quot;</span>;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680     die $mess;
<a name="l00681"></a>00681 }
<a name="l00682"></a>00682 
<a name="l00683"></a>00683 <span class="preprocessor">#</span>
<a name="l00684"></a>00684 <span class="preprocessor"></span><span class="preprocessor"># (log)</span>
<a name="l00685"></a>00685 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00686"></a>00686 <span class="preprocessor"></span><span class="preprocessor"># Compute log(z).</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00688"></a>00688 <span class="preprocessor"></span>sub log {
<a name="l00689"></a>00689     my ($z) = @_;
<a name="l00690"></a>00690     unless (ref $z) {
<a name="l00691"></a>00691         _logofzero(<span class="stringliteral">&quot;log&quot;</span>) if $z == 0;
<a name="l00692"></a>00692         return $z &gt; 0 ? CORE::log($z) : cplx(CORE::log(-$z), pi);
<a name="l00693"></a>00693     }
<a name="l00694"></a>00694     my ($r, $t) = @{$z-&gt;polar};
<a name="l00695"></a>00695     _logofzero(<span class="stringliteral">&quot;log&quot;</span>) if $r == 0;
<a name="l00696"></a>00696     if    ($t &gt;   pi()) { $t -= pit2 }
<a name="l00697"></a>00697     elsif ($t &lt;= -pi()) { $t += pit2 }
<a name="l00698"></a>00698     <span class="keywordflow">return</span> (ref $z)-&gt;make(CORE::log($r), $t);
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 <span class="preprocessor">#</span>
<a name="l00702"></a>00702 <span class="preprocessor"></span><span class="preprocessor"># ln</span>
<a name="l00703"></a>00703 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span><span class="preprocessor"># Alias for log().</span>
<a name="l00705"></a>00705 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00706"></a>00706 <span class="preprocessor"></span>sub ln { <a class="code" href="classComplex1.html#a2dae55373f4ea96e452e578a741d12f7">Complex1::log</a>(@_) }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708 <span class="preprocessor">#</span>
<a name="l00709"></a>00709 <span class="preprocessor"></span><span class="preprocessor"># log10</span>
<a name="l00710"></a>00710 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00711"></a>00711 <span class="preprocessor"></span><span class="preprocessor"># Compute log10(z).</span>
<a name="l00712"></a>00712 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00713"></a>00713 <span class="preprocessor"></span>
<a name="l00714"></a>00714 sub log10 {
<a name="l00715"></a>00715     <span class="keywordflow">return</span> <a class="code" href="classComplex1.html#a2dae55373f4ea96e452e578a741d12f7">Complex1::log</a>($_[0]) * uplog10;
<a name="l00716"></a>00716 }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718 <span class="preprocessor">#</span>
<a name="l00719"></a>00719 <span class="preprocessor"></span><span class="preprocessor"># logn</span>
<a name="l00720"></a>00720 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00721"></a>00721 <span class="preprocessor"></span><span class="preprocessor"># Compute logn(z,n) = log(z) / log(n)</span>
<a name="l00722"></a>00722 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00723"></a>00723 <span class="preprocessor"></span>sub logn {
<a name="l00724"></a>00724     my ($z, $n) = @_;
<a name="l00725"></a>00725     $z = cplx($z, 0) unless ref $z;
<a name="l00726"></a>00726     my $logn = $logn{$n};
<a name="l00727"></a>00727     $logn = $logn{$n} = CORE::log($n) unless defined $logn; <span class="preprocessor"># Cache log(n)</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span>    <span class="keywordflow">return</span> CORE::log($z) / $logn;
<a name="l00729"></a>00729 }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731 <span class="preprocessor">#</span>
<a name="l00732"></a>00732 <span class="preprocessor"></span><span class="preprocessor"># (cos)</span>
<a name="l00733"></a>00733 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00734"></a>00734 <span class="preprocessor"></span><span class="preprocessor"># Compute cos(z) = (exp(iz) + exp(-iz))/2.</span>
<a name="l00735"></a>00735 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00736"></a>00736 <span class="preprocessor"></span>sub cos {
<a name="l00737"></a>00737     my ($z) = @_;
<a name="l00738"></a>00738     my ($x, $y) = @{$z-&gt;cartesian};
<a name="l00739"></a>00739     my $ey = CORE::exp($y);
<a name="l00740"></a>00740     my $ey_1 = 1 / $ey;
<a name="l00741"></a>00741     <span class="keywordflow">return</span> (ref $z)-&gt;make(CORE::cos($x) * ($ey + $ey_1)/2,
<a name="l00742"></a>00742                   CORE::sin($x) * ($ey_1 - $ey)/2);
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 <span class="preprocessor">#</span>
<a name="l00746"></a>00746 <span class="preprocessor"></span><span class="preprocessor"># (sin)</span>
<a name="l00747"></a>00747 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00748"></a>00748 <span class="preprocessor"></span><span class="preprocessor"># Compute sin(z) = (exp(iz) - exp(-iz))/2.</span>
<a name="l00749"></a>00749 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00750"></a>00750 <span class="preprocessor"></span>sub sin {
<a name="l00751"></a>00751     my ($z) = @_;
<a name="l00752"></a>00752     my ($x, $y) = @{$z-&gt;cartesian};
<a name="l00753"></a>00753     my $ey = CORE::exp($y);
<a name="l00754"></a>00754     my $ey_1 = 1 / $ey;
<a name="l00755"></a>00755     <span class="keywordflow">return</span> (ref $z)-&gt;make(CORE::sin($x) * ($ey + $ey_1)/2,
<a name="l00756"></a>00756                   CORE::cos($x) * ($ey - $ey_1)/2);
<a name="l00757"></a>00757 }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759 <span class="preprocessor">#</span>
<a name="l00760"></a>00760 <span class="preprocessor"></span><span class="preprocessor"># tan</span>
<a name="l00761"></a>00761 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00762"></a>00762 <span class="preprocessor"></span><span class="preprocessor"># Compute tan(z) = sin(z) / cos(z).</span>
<a name="l00763"></a>00763 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00764"></a>00764 <span class="preprocessor"></span>sub tan {
<a name="l00765"></a>00765     my ($z) = @_;
<a name="l00766"></a>00766     my $cz = CORE::cos($z);
<a name="l00767"></a>00767     _divbyzero <span class="stringliteral">&quot;tan($z)&quot;</span>, <span class="stringliteral">&quot;cos($z)&quot;</span> <span class="keywordflow">if</span> (CORE::abs($cz) &lt; $eps);
<a name="l00768"></a>00768     <span class="keywordflow">return</span> CORE::sin($z) / $cz;
<a name="l00769"></a>00769 }
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 <span class="preprocessor">#</span>
<a name="l00772"></a>00772 <span class="preprocessor"></span><span class="preprocessor"># sec</span>
<a name="l00773"></a>00773 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00774"></a>00774 <span class="preprocessor"></span><span class="preprocessor"># Computes the secant sec(z) = 1 / cos(z).</span>
<a name="l00775"></a>00775 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00776"></a>00776 <span class="preprocessor"></span>sub sec {
<a name="l00777"></a>00777     my ($z) = @_;
<a name="l00778"></a>00778     my $cz = CORE::cos($z);
<a name="l00779"></a>00779     _divbyzero <span class="stringliteral">&quot;sec($z)&quot;</span>, <span class="stringliteral">&quot;cos($z)&quot;</span> <span class="keywordflow">if</span> ($cz == 0);
<a name="l00780"></a>00780     <span class="keywordflow">return</span> 1 / $cz;
<a name="l00781"></a>00781 }
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 <span class="preprocessor">#</span>
<a name="l00784"></a>00784 <span class="preprocessor"></span><span class="preprocessor"># csc</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00786"></a>00786 <span class="preprocessor"></span><span class="preprocessor"># Computes the cosecant csc(z) = 1 / sin(z).</span>
<a name="l00787"></a>00787 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00788"></a>00788 <span class="preprocessor"></span>sub csc {
<a name="l00789"></a>00789     my ($z) = @_;
<a name="l00790"></a>00790     my $sz = CORE::sin($z);
<a name="l00791"></a>00791     _divbyzero <span class="stringliteral">&quot;csc($z)&quot;</span>, <span class="stringliteral">&quot;sin($z)&quot;</span> <span class="keywordflow">if</span> ($sz == 0);
<a name="l00792"></a>00792     <span class="keywordflow">return</span> 1 / $sz;
<a name="l00793"></a>00793 }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795 <span class="preprocessor">#</span>
<a name="l00796"></a>00796 <span class="preprocessor"></span><span class="preprocessor"># cosec</span>
<a name="l00797"></a>00797 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00798"></a>00798 <span class="preprocessor"></span><span class="preprocessor"># Alias for csc().</span>
<a name="l00799"></a>00799 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00800"></a>00800 <span class="preprocessor"></span>sub cosec { <a class="code" href="classComplex1.html#aefa08cd87317ae783e203a0ea71ed506">Complex1::csc</a>(@_) }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 <span class="preprocessor">#</span>
<a name="l00803"></a>00803 <span class="preprocessor"></span><span class="preprocessor"># cot</span>
<a name="l00804"></a>00804 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span><span class="preprocessor"># Computes cot(z) = cos(z) / sin(z).</span>
<a name="l00806"></a>00806 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00807"></a>00807 <span class="preprocessor"></span>sub cot {
<a name="l00808"></a>00808     my ($z) = @_;
<a name="l00809"></a>00809     my $sz = CORE::sin($z);
<a name="l00810"></a>00810     _divbyzero <span class="stringliteral">&quot;cot($z)&quot;</span>, <span class="stringliteral">&quot;sin($z)&quot;</span> <span class="keywordflow">if</span> ($sz == 0);
<a name="l00811"></a>00811     <span class="keywordflow">return</span> CORE::cos($z) / $sz;
<a name="l00812"></a>00812 }
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 <span class="preprocessor">#</span>
<a name="l00815"></a>00815 <span class="preprocessor"></span><span class="preprocessor"># cotan</span>
<a name="l00816"></a>00816 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00817"></a>00817 <span class="preprocessor"></span><span class="preprocessor"># Alias for cot().</span>
<a name="l00818"></a>00818 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00819"></a>00819 <span class="preprocessor"></span>sub cotan { <a class="code" href="classComplex1.html#a1bab47b2a0917a700df4c6bbf311a961">Complex1::cot</a>(@_) }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 <span class="preprocessor">#</span>
<a name="l00822"></a>00822 <span class="preprocessor"></span><span class="preprocessor"># acos</span>
<a name="l00823"></a>00823 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00824"></a>00824 <span class="preprocessor"></span><span class="preprocessor"># Computes the arc cosine acos(z) = -i log(z + sqrt(z*z-1)).</span>
<a name="l00825"></a>00825 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00826"></a>00826 <span class="preprocessor"></span>sub acos {
<a name="l00827"></a>00827     my $z = $_[0];
<a name="l00828"></a>00828     <span class="keywordflow">return</span> CORE::atan2(CORE::sqrt(1-$z*$z), $z) if (! ref $z) &amp;&amp; CORE::abs($z) &lt;= 1;
<a name="l00829"></a>00829     my ($x, $y) = ref $z ? @{$z-&gt;cartesian} : ($z, 0);
<a name="l00830"></a>00830     my $t1 = CORE::sqrt(($x+1)*($x+1) + $y*$y);
<a name="l00831"></a>00831     my $t2 = CORE::sqrt(($x-1)*($x-1) + $y*$y);
<a name="l00832"></a>00832     my $alpha = ($t1 + $t2)/2;
<a name="l00833"></a>00833     my $beta  = ($t1 - $t2)/2;
<a name="l00834"></a>00834     $alpha = 1 <span class="keywordflow">if</span> $alpha &lt; 1;
<a name="l00835"></a>00835     <span class="keywordflow">if</span>    ($beta &gt;  1) { $beta =  1 }
<a name="l00836"></a>00836     elsif ($beta &lt; -1) { $beta = -1 }
<a name="l00837"></a>00837     my $u = CORE::atan2(CORE::sqrt(1-$beta*$beta), $beta);
<a name="l00838"></a>00838     my $v = CORE::log($alpha + CORE::sqrt($alpha*$alpha-1));
<a name="l00839"></a>00839     $v = -$v <span class="keywordflow">if</span> $y &gt; 0 || ($y == 0 &amp;&amp; $x &lt; -1);
<a name="l00840"></a>00840     <span class="keywordflow">return</span> $package-&gt;make($u, $v);
<a name="l00841"></a>00841 }
<a name="l00842"></a>00842 
<a name="l00843"></a>00843 <span class="preprocessor">#</span>
<a name="l00844"></a>00844 <span class="preprocessor"></span><span class="preprocessor"># asin</span>
<a name="l00845"></a>00845 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00846"></a>00846 <span class="preprocessor"></span><span class="preprocessor"># Computes the arc sine asin(z) = -i log(iz + sqrt(1-z*z)).</span>
<a name="l00847"></a>00847 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00848"></a>00848 <span class="preprocessor"></span>sub asin {
<a name="l00849"></a>00849     my $z = $_[0];
<a name="l00850"></a>00850     <span class="keywordflow">return</span> CORE::atan2($z, CORE::sqrt(1-$z*$z)) <span class="keywordflow">if</span> (! ref $z) &amp;&amp; CORE::abs($z) &lt;= 1;
<a name="l00851"></a>00851     my ($x, $y) = ref $z ? @{$z-&gt;cartesian} : ($z, 0);
<a name="l00852"></a>00852     my $t1 = CORE::sqrt(($x+1)*($x+1) + $y*$y);
<a name="l00853"></a>00853     my $t2 = CORE::sqrt(($x-1)*($x-1) + $y*$y);
<a name="l00854"></a>00854     my $alpha = ($t1 + $t2)/2;
<a name="l00855"></a>00855     my $beta  = ($t1 - $t2)/2;
<a name="l00856"></a>00856     $alpha = 1 <span class="keywordflow">if</span> $alpha &lt; 1;
<a name="l00857"></a>00857     <span class="keywordflow">if</span>    ($beta &gt;  1) { $beta =  1 }
<a name="l00858"></a>00858     elsif ($beta &lt; -1) { $beta = -1 }
<a name="l00859"></a>00859     my $u =  CORE::atan2($beta, CORE::sqrt(1-$beta*$beta));
<a name="l00860"></a>00860     my $v = -CORE::log($alpha + CORE::sqrt($alpha*$alpha-1));
<a name="l00861"></a>00861     $v = -$v <span class="keywordflow">if</span> $y &gt; 0 || ($y == 0 &amp;&amp; $x &lt; -1);
<a name="l00862"></a>00862     <span class="keywordflow">return</span> $package-&gt;make($u, $v);
<a name="l00863"></a>00863 }
<a name="l00864"></a>00864 
<a name="l00865"></a>00865 <span class="preprocessor">#</span>
<a name="l00866"></a>00866 <span class="preprocessor"></span><span class="preprocessor"># atan</span>
<a name="l00867"></a>00867 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00868"></a>00868 <span class="preprocessor"></span><span class="preprocessor"># Computes the arc tangent atan(z) = i/2 log((i+z) / (i-z)).</span>
<a name="l00869"></a>00869 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00870"></a>00870 <span class="preprocessor"></span>sub atan {
<a name="l00871"></a>00871     my ($z) = @_;
<a name="l00872"></a>00872     <span class="keywordflow">return</span> CORE::atan2($z, 1) unless ref $z;
<a name="l00873"></a>00873     _divbyzero &quot;atan(i)&quot;  if ( $z == i);
<a name="l00874"></a>00874     _divbyzero &quot;atan(-i)&quot; if (-$z == i);
<a name="l00875"></a>00875     my $log = CORE::log((i + $z) / (i - $z));
<a name="l00876"></a>00876     $ip2 = 0.5 * i unless defined $ip2;
<a name="l00877"></a>00877     return $ip2 * $log;
<a name="l00878"></a>00878 }
<a name="l00879"></a>00879 
<a name="l00880"></a>00880 <span class="preprocessor">#</span>
<a name="l00881"></a>00881 <span class="preprocessor"></span><span class="preprocessor"># asec</span>
<a name="l00882"></a>00882 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00883"></a>00883 <span class="preprocessor"></span><span class="preprocessor"># Computes the arc secant asec(z) = acos(1 / z).</span>
<a name="l00884"></a>00884 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00885"></a>00885 <span class="preprocessor"></span>sub asec {
<a name="l00886"></a>00886     my ($z) = @_;
<a name="l00887"></a>00887     _divbyzero <span class="stringliteral">&quot;asec($z)&quot;</span>, $z <span class="keywordflow">if</span> ($z == 0);
<a name="l00888"></a>00888     <span class="keywordflow">return</span> acos(1 / $z);
<a name="l00889"></a>00889 }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 <span class="preprocessor">#</span>
<a name="l00892"></a>00892 <span class="preprocessor"></span><span class="preprocessor"># acsc</span>
<a name="l00893"></a>00893 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00894"></a>00894 <span class="preprocessor"></span><span class="preprocessor"># Computes the arc cosecant acsc(z) = asin(1 / z).</span>
<a name="l00895"></a>00895 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00896"></a>00896 <span class="preprocessor"></span>sub acsc {
<a name="l00897"></a>00897     my ($z) = @_;
<a name="l00898"></a>00898     _divbyzero <span class="stringliteral">&quot;acsc($z)&quot;</span>, $z <span class="keywordflow">if</span> ($z == 0);
<a name="l00899"></a>00899     <span class="keywordflow">return</span> asin(1 / $z);
<a name="l00900"></a>00900 }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 <span class="preprocessor">#</span>
<a name="l00903"></a>00903 <span class="preprocessor"></span><span class="preprocessor"># acosec</span>
<a name="l00904"></a>00904 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00905"></a>00905 <span class="preprocessor"></span><span class="preprocessor"># Alias for acsc().</span>
<a name="l00906"></a>00906 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00907"></a>00907 <span class="preprocessor"></span>sub acosec { <a class="code" href="classComplex1.html#aa706ae688fdc5f92902c808ad6c5f2bb">Complex1::acsc</a>(@_) }
<a name="l00908"></a>00908 
<a name="l00909"></a>00909 <span class="preprocessor">#</span>
<a name="l00910"></a>00910 <span class="preprocessor"></span><span class="preprocessor"># acot</span>
<a name="l00911"></a>00911 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00912"></a>00912 <span class="preprocessor"></span><span class="preprocessor"># Computes the arc cotangent acot(z) = atan(1 / z)</span>
<a name="l00913"></a>00913 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00914"></a>00914 <span class="preprocessor"></span>sub acot {
<a name="l00915"></a>00915     my ($z) = @_;
<a name="l00916"></a>00916     _divbyzero <span class="stringliteral">&quot;acot(0)&quot;</span>  <span class="keywordflow">if</span> (CORE::abs($z)     &lt; $eps);
<a name="l00917"></a>00917     <span class="keywordflow">return</span> ($z &gt;= 0) ? CORE::atan2(1, $z) : CORE::atan2(-1, -$z) unless ref $z;
<a name="l00918"></a>00918     _divbyzero <span class="stringliteral">&quot;acot(i)&quot;</span>  <span class="keywordflow">if</span> (CORE::abs($z - i) &lt; $eps);
<a name="l00919"></a>00919     _logofzero <span class="stringliteral">&quot;acot(-i)&quot;</span> <span class="keywordflow">if</span> (CORE::abs($z + i) &lt; $eps);
<a name="l00920"></a>00920     <span class="keywordflow">return</span> atan(1 / $z);
<a name="l00921"></a>00921 }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923 <span class="preprocessor">#</span>
<a name="l00924"></a>00924 <span class="preprocessor"></span><span class="preprocessor"># acotan</span>
<a name="l00925"></a>00925 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00926"></a>00926 <span class="preprocessor"></span><span class="preprocessor"># Alias for acot().</span>
<a name="l00927"></a>00927 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00928"></a>00928 <span class="preprocessor"></span>sub acotan { <a class="code" href="classComplex1.html#a15088c85f8e4f39d9511ae9f16797b59">Complex1::acot</a>(@_) }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 <span class="preprocessor">#</span>
<a name="l00931"></a>00931 <span class="preprocessor"></span><span class="preprocessor"># cosh</span>
<a name="l00932"></a>00932 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00933"></a>00933 <span class="preprocessor"></span><span class="preprocessor"># Computes the hyperbolic cosine cosh(z) = (exp(z) + exp(-z))/2.</span>
<a name="l00934"></a>00934 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00935"></a>00935 <span class="preprocessor"></span>sub cosh {
<a name="l00936"></a>00936     my ($z) = @_;
<a name="l00937"></a>00937     my $ex;
<a name="l00938"></a>00938     unless (ref $z) {
<a name="l00939"></a>00939         $ex = CORE::exp($z);
<a name="l00940"></a>00940         <span class="keywordflow">return</span> ($ex + 1/$ex)/2;
<a name="l00941"></a>00941     }
<a name="l00942"></a>00942     my ($x, $y) = @{$z-&gt;cartesian};
<a name="l00943"></a>00943     $ex = CORE::exp($x);
<a name="l00944"></a>00944     my $ex_1 = 1 / $ex;
<a name="l00945"></a>00945     <span class="keywordflow">return</span> (ref $z)-&gt;make(CORE::cos($y) * ($ex + $ex_1)/2,
<a name="l00946"></a>00946                   CORE::sin($y) * ($ex - $ex_1)/2);
<a name="l00947"></a>00947 }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949 <span class="preprocessor">#</span>
<a name="l00950"></a>00950 <span class="preprocessor"></span><span class="preprocessor"># sinh</span>
<a name="l00951"></a>00951 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00952"></a>00952 <span class="preprocessor"></span><span class="preprocessor"># Computes the hyperbolic sine sinh(z) = (exp(z) - exp(-z))/2.</span>
<a name="l00953"></a>00953 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00954"></a>00954 <span class="preprocessor"></span>sub sinh {
<a name="l00955"></a>00955     my ($z) = @_;
<a name="l00956"></a>00956     my $ex;
<a name="l00957"></a>00957     unless (ref $z) {
<a name="l00958"></a>00958         $ex = CORE::exp($z);
<a name="l00959"></a>00959         <span class="keywordflow">return</span> ($ex - 1/$ex)/2;
<a name="l00960"></a>00960     }
<a name="l00961"></a>00961     my ($x, $y) = @{$z-&gt;cartesian};
<a name="l00962"></a>00962     $ex = CORE::exp($x);
<a name="l00963"></a>00963     my $ex_1 = 1 / $ex;
<a name="l00964"></a>00964     <span class="keywordflow">return</span> (ref $z)-&gt;make(CORE::cos($y) * ($ex - $ex_1)/2,
<a name="l00965"></a>00965                   CORE::sin($y) * ($ex + $ex_1)/2);
<a name="l00966"></a>00966 }
<a name="l00967"></a>00967 
<a name="l00968"></a>00968 <span class="preprocessor">#</span>
<a name="l00969"></a>00969 <span class="preprocessor"></span><span class="preprocessor"># tanh</span>
<a name="l00970"></a>00970 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00971"></a>00971 <span class="preprocessor"></span><span class="preprocessor"># Computes the hyperbolic tangent tanh(z) = sinh(z) / cosh(z).</span>
<a name="l00972"></a>00972 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00973"></a>00973 <span class="preprocessor"></span>sub tanh {
<a name="l00974"></a>00974     my ($z) = @_;
<a name="l00975"></a>00975     my $cz = cosh($z);
<a name="l00976"></a>00976     _divbyzero <span class="stringliteral">&quot;tanh($z)&quot;</span>, <span class="stringliteral">&quot;cosh($z)&quot;</span> <span class="keywordflow">if</span> ($cz == 0);
<a name="l00977"></a>00977     <span class="keywordflow">return</span> sinh($z) / $cz;
<a name="l00978"></a>00978 }
<a name="l00979"></a>00979 
<a name="l00980"></a>00980 <span class="preprocessor">#</span>
<a name="l00981"></a>00981 <span class="preprocessor"></span><span class="preprocessor"># sech</span>
<a name="l00982"></a>00982 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00983"></a>00983 <span class="preprocessor"></span><span class="preprocessor"># Computes the hyperbolic secant sech(z) = 1 / cosh(z).</span>
<a name="l00984"></a>00984 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00985"></a>00985 <span class="preprocessor"></span>sub sech {
<a name="l00986"></a>00986     my ($z) = @_;
<a name="l00987"></a>00987     my $cz = cosh($z);
<a name="l00988"></a>00988     _divbyzero <span class="stringliteral">&quot;sech($z)&quot;</span>, <span class="stringliteral">&quot;cosh($z)&quot;</span> <span class="keywordflow">if</span> ($cz == 0);
<a name="l00989"></a>00989     <span class="keywordflow">return</span> 1 / $cz;
<a name="l00990"></a>00990 }
<a name="l00991"></a>00991 
<a name="l00992"></a>00992 <span class="preprocessor">#</span>
<a name="l00993"></a>00993 <span class="preprocessor"></span><span class="preprocessor"># csch</span>
<a name="l00994"></a>00994 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00995"></a>00995 <span class="preprocessor"></span><span class="preprocessor"># Computes the hyperbolic cosecant csch(z) = 1 / sinh(z).</span>
<a name="l00996"></a>00996 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00997"></a>00997 <span class="preprocessor"></span>sub csch {
<a name="l00998"></a>00998     my ($z) = @_;
<a name="l00999"></a>00999     my $sz = sinh($z);
<a name="l01000"></a>01000     _divbyzero <span class="stringliteral">&quot;csch($z)&quot;</span>, <span class="stringliteral">&quot;sinh($z)&quot;</span> <span class="keywordflow">if</span> ($sz == 0);
<a name="l01001"></a>01001     <span class="keywordflow">return</span> 1 / $sz;
<a name="l01002"></a>01002 }
<a name="l01003"></a>01003 
<a name="l01004"></a>01004 <span class="preprocessor">#</span>
<a name="l01005"></a>01005 <span class="preprocessor"></span><span class="preprocessor"># cosech</span>
<a name="l01006"></a>01006 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01007"></a>01007 <span class="preprocessor"></span><span class="preprocessor"># Alias for csch().</span>
<a name="l01008"></a>01008 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01009"></a>01009 <span class="preprocessor"></span>sub cosech { <a class="code" href="classComplex1.html#a50951e70ec11a51c1d812141048f8a55">Complex1::csch</a>(@_) }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 <span class="preprocessor">#</span>
<a name="l01012"></a>01012 <span class="preprocessor"></span><span class="preprocessor"># coth</span>
<a name="l01013"></a>01013 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01014"></a>01014 <span class="preprocessor"></span><span class="preprocessor"># Computes the hyperbolic cotangent coth(z) = cosh(z) / sinh(z).</span>
<a name="l01015"></a>01015 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01016"></a>01016 <span class="preprocessor"></span>sub coth {
<a name="l01017"></a>01017     my ($z) = @_;
<a name="l01018"></a>01018     my $sz = sinh($z);
<a name="l01019"></a>01019     _divbyzero <span class="stringliteral">&quot;coth($z)&quot;</span>, <span class="stringliteral">&quot;sinh($z)&quot;</span> <span class="keywordflow">if</span> ($sz == 0);
<a name="l01020"></a>01020     <span class="keywordflow">return</span> cosh($z) / $sz;
<a name="l01021"></a>01021 }
<a name="l01022"></a>01022 
<a name="l01023"></a>01023 <span class="preprocessor">#</span>
<a name="l01024"></a>01024 <span class="preprocessor"></span><span class="preprocessor"># cotanh</span>
<a name="l01025"></a>01025 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01026"></a>01026 <span class="preprocessor"></span><span class="preprocessor"># Alias for coth().</span>
<a name="l01027"></a>01027 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01028"></a>01028 <span class="preprocessor"></span>sub cotanh { <a class="code" href="classComplex1.html#a38c6deae852f200bffe38decb9982a10">Complex1::coth</a>(@_) }
<a name="l01029"></a>01029 
<a name="l01030"></a>01030 <span class="preprocessor">#</span>
<a name="l01031"></a>01031 <span class="preprocessor"></span><span class="preprocessor"># acosh</span>
<a name="l01032"></a>01032 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01033"></a>01033 <span class="preprocessor"></span><span class="preprocessor"># Computes the arc hyperbolic cosine acosh(z) = log(z + sqrt(z*z-1)).</span>
<a name="l01034"></a>01034 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01035"></a>01035 <span class="preprocessor"></span>sub acosh {
<a name="l01036"></a>01036     my ($z) = @_;
<a name="l01037"></a>01037     unless (ref $z) {
<a name="l01038"></a>01038         <span class="keywordflow">return</span> CORE::log($z + CORE::sqrt($z*$z-1)) if $z &gt;= 1;
<a name="l01039"></a>01039         $z = cplx($z, 0);
<a name="l01040"></a>01040     }
<a name="l01041"></a>01041     my ($re, $im) = @{$z-&gt;cartesian};
<a name="l01042"></a>01042     <span class="keywordflow">if</span> ($im == 0) {
<a name="l01043"></a>01043         <span class="keywordflow">return</span> cplx(CORE::log($re + CORE::sqrt($re*$re - 1)), 0) if $re &gt;= 1;
<a name="l01044"></a>01044         return cplx(0, CORE::atan2(CORE::sqrt(1-$re*$re), $re)) if CORE::abs($re) &lt;= 1;
<a name="l01045"></a>01045     }
<a name="l01046"></a>01046     return CORE::log($z + CORE::sqrt($z*$z - 1));
<a name="l01047"></a>01047 }
<a name="l01048"></a>01048 
<a name="l01049"></a>01049 <span class="preprocessor">#</span>
<a name="l01050"></a>01050 <span class="preprocessor"></span><span class="preprocessor"># asinh</span>
<a name="l01051"></a>01051 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01052"></a>01052 <span class="preprocessor"></span><span class="preprocessor"># Computes the arc hyperbolic sine asinh(z) = log(z + sqrt(z*z-1))</span>
<a name="l01053"></a>01053 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01054"></a>01054 <span class="preprocessor"></span>sub asinh {
<a name="l01055"></a>01055     my ($z) = @_;
<a name="l01056"></a>01056     <span class="keywordflow">return</span> CORE::log($z + CORE::sqrt($z*$z + 1));
<a name="l01057"></a>01057 }
<a name="l01058"></a>01058 
<a name="l01059"></a>01059 <span class="preprocessor">#</span>
<a name="l01060"></a>01060 <span class="preprocessor"></span><span class="preprocessor"># atanh</span>
<a name="l01061"></a>01061 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01062"></a>01062 <span class="preprocessor"></span><span class="preprocessor"># Computes the arc hyperbolic tangent atanh(z) = 1/2 log((1+z) / (1-z)).</span>
<a name="l01063"></a>01063 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01064"></a>01064 <span class="preprocessor"></span>sub atanh {
<a name="l01065"></a>01065     my ($z) = @_;
<a name="l01066"></a>01066     unless (ref $z) {
<a name="l01067"></a>01067         <span class="keywordflow">return</span> CORE::log((1 + $z)/(1 - $z))/2 <span class="keywordflow">if</span> CORE::abs($z) &lt; 1;
<a name="l01068"></a>01068         $z = cplx($z, 0);
<a name="l01069"></a>01069     }
<a name="l01070"></a>01070     _divbyzero <span class="stringliteral">&#39;atanh(1)&#39;</span>,  <span class="stringliteral">&quot;1 - $z&quot;</span> <span class="keywordflow">if</span> ($z ==  1);
<a name="l01071"></a>01071     _logofzero <span class="stringliteral">&#39;atanh(-1)&#39;</span>           <span class="keywordflow">if</span> ($z == -1);
<a name="l01072"></a>01072     <span class="keywordflow">return</span> 0.5 * CORE::log((1 + $z) / (1 - $z));
<a name="l01073"></a>01073 }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075 <span class="preprocessor">#</span>
<a name="l01076"></a>01076 <span class="preprocessor"></span><span class="preprocessor"># asech</span>
<a name="l01077"></a>01077 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01078"></a>01078 <span class="preprocessor"></span><span class="preprocessor"># Computes the hyperbolic arc secant asech(z) = acosh(1 / z).</span>
<a name="l01079"></a>01079 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01080"></a>01080 <span class="preprocessor"></span>sub asech {
<a name="l01081"></a>01081     my ($z) = @_;
<a name="l01082"></a>01082     _divbyzero <span class="stringliteral">&#39;asech(0)&#39;</span>, $z <span class="keywordflow">if</span> ($z == 0);
<a name="l01083"></a>01083     <span class="keywordflow">return</span> acosh(1 / $z);
<a name="l01084"></a>01084 }
<a name="l01085"></a>01085 
<a name="l01086"></a>01086 <span class="preprocessor">#</span>
<a name="l01087"></a>01087 <span class="preprocessor"></span><span class="preprocessor"># acsch</span>
<a name="l01088"></a>01088 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01089"></a>01089 <span class="preprocessor"></span><span class="preprocessor"># Computes the hyperbolic arc cosecant acsch(z) = asinh(1 / z).</span>
<a name="l01090"></a>01090 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01091"></a>01091 <span class="preprocessor"></span>sub acsch {
<a name="l01092"></a>01092     my ($z) = @_;
<a name="l01093"></a>01093     _divbyzero <span class="stringliteral">&#39;acsch(0)&#39;</span>, $z <span class="keywordflow">if</span> ($z == 0);
<a name="l01094"></a>01094     <span class="keywordflow">return</span> asinh(1 / $z);
<a name="l01095"></a>01095 }
<a name="l01096"></a>01096 
<a name="l01097"></a>01097 <span class="preprocessor">#</span>
<a name="l01098"></a>01098 <span class="preprocessor"></span><span class="preprocessor"># acosech</span>
<a name="l01099"></a>01099 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01100"></a>01100 <span class="preprocessor"></span><span class="preprocessor"># Alias for acosh().</span>
<a name="l01101"></a>01101 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01102"></a>01102 <span class="preprocessor"></span>sub acosech { <a class="code" href="classComplex1.html#a9e4da5c7215a7c6a00e0b31ecef1ba7d">Complex1::acsch</a>(@_) }
<a name="l01103"></a>01103 
<a name="l01104"></a>01104 <span class="preprocessor">#</span>
<a name="l01105"></a>01105 <span class="preprocessor"></span><span class="preprocessor"># acoth</span>
<a name="l01106"></a>01106 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01107"></a>01107 <span class="preprocessor"></span><span class="preprocessor"># Computes the arc hyperbolic cotangent acoth(z) = 1/2 log((1+z) / (z-1)).</span>
<a name="l01108"></a>01108 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01109"></a>01109 <span class="preprocessor"></span>sub acoth {
<a name="l01110"></a>01110     my ($z) = @_;
<a name="l01111"></a>01111     _divbyzero <span class="stringliteral">&#39;acoth(0)&#39;</span>            <span class="keywordflow">if</span> (CORE::abs($z)     &lt; $eps);
<a name="l01112"></a>01112     unless (ref $z) {
<a name="l01113"></a>01113         <span class="keywordflow">return</span> CORE::log(($z + 1)/($z - 1))/2 <span class="keywordflow">if</span> CORE::abs($z) &gt; 1;
<a name="l01114"></a>01114         $z = cplx($z, 0);
<a name="l01115"></a>01115     }
<a name="l01116"></a>01116     _divbyzero <span class="stringliteral">&#39;acoth(1)&#39;</span>,  <span class="stringliteral">&quot;$z - 1&quot;</span> <span class="keywordflow">if</span> (CORE::abs($z - 1) &lt; $eps);
<a name="l01117"></a>01117     _logofzero <span class="stringliteral">&#39;acoth(-1)&#39;</span>, <span class="stringliteral">&quot;1 / $z&quot;</span> <span class="keywordflow">if</span> (CORE::abs($z + 1) &lt; $eps);
<a name="l01118"></a>01118     <span class="keywordflow">return</span> CORE::log((1 + $z) / ($z - 1)) / 2;
<a name="l01119"></a>01119 }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121 <span class="preprocessor">#</span>
<a name="l01122"></a>01122 <span class="preprocessor"></span><span class="preprocessor"># acotanh</span>
<a name="l01123"></a>01123 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01124"></a>01124 <span class="preprocessor"></span><span class="preprocessor"># Alias for acot().</span>
<a name="l01125"></a>01125 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01126"></a>01126 <span class="preprocessor"></span>sub acotanh { <a class="code" href="classComplex1.html#a9c7337bd2d1999c21294e65c090d6f00">Complex1::acoth</a>(@_) }
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 <span class="preprocessor">#</span>
<a name="l01129"></a>01129 <span class="preprocessor"></span><span class="preprocessor"># (atan2)</span>
<a name="l01130"></a>01130 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01131"></a>01131 <span class="preprocessor"></span><span class="preprocessor"># Compute atan(z1/z2).</span>
<a name="l01132"></a>01132 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01133"></a>01133 <span class="preprocessor"></span>sub atan2 {
<a name="l01134"></a>01134     my ($z1, $z2, $inverted) = @_;
<a name="l01135"></a>01135     my ($re1, $im1, $re2, $im2);
<a name="l01136"></a>01136     <span class="keywordflow">if</span> ($inverted) {
<a name="l01137"></a>01137         ($re1, $im1) = ref $z2 ? @{$z2-&gt;cartesian} : ($z2, 0);
<a name="l01138"></a>01138         ($re2, $im2) = @{$z1-&gt;cartesian};
<a name="l01139"></a>01139     } <span class="keywordflow">else</span> {
<a name="l01140"></a>01140         ($re1, $im1) = @{$z1-&gt;cartesian};
<a name="l01141"></a>01141         ($re2, $im2) = ref $z2 ? @{$z2-&gt;cartesian} : ($z2, 0);
<a name="l01142"></a>01142     }
<a name="l01143"></a>01143     <span class="keywordflow">if</span> ($im2 == 0) {
<a name="l01144"></a>01144         <span class="keywordflow">return</span> cplx(CORE::atan2($re1, $re2), 0) if $im1 == 0;
<a name="l01145"></a>01145         return cplx(($im1&lt;=&gt;0) * pip2, 0) if $re2 == 0;
<a name="l01146"></a>01146     }
<a name="l01147"></a>01147     my $w = atan($z1/$z2);
<a name="l01148"></a>01148     my ($u, $v) = ref $w ? @{$w-&gt;cartesian} : ($w, 0);
<a name="l01149"></a>01149     $u += pi   <span class="keywordflow">if</span> $re2 &lt; 0;
<a name="l01150"></a>01150     $u -= pit2 <span class="keywordflow">if</span> $u &gt; pi;
<a name="l01151"></a>01151     <span class="keywordflow">return</span> cplx($u, $v);
<a name="l01152"></a>01152 }
<a name="l01153"></a>01153 
<a name="l01154"></a>01154 <span class="preprocessor">#</span>
<a name="l01155"></a>01155 <span class="preprocessor"></span><span class="preprocessor"># display_format</span>
<a name="l01156"></a>01156 <span class="preprocessor"></span><span class="preprocessor"># -&gt;display_format</span>
<a name="l01157"></a>01157 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01158"></a>01158 <span class="preprocessor"></span><span class="preprocessor"># Set (fetch if no argument) display format for all complex numbers that</span>
<a name="l01159"></a>01159 <span class="preprocessor"></span><span class="preprocessor"># don&#39;t happen to have overridden it via -&gt;display_format</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01161"></a>01161 <span class="preprocessor"></span><span class="preprocessor"># When called as a method, this actually sets the display format for</span>
<a name="l01162"></a>01162 <span class="preprocessor"></span><span class="preprocessor"># the current object.</span>
<a name="l01163"></a>01163 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01164"></a>01164 <span class="preprocessor"></span><span class="preprocessor"># Valid object formats are &#39;c&#39; and &#39;p&#39; for cartesian and polar. The first</span>
<a name="l01165"></a>01165 <span class="preprocessor"></span><span class="preprocessor"># letter is used actually, so the type can be fully spelled out for clarity.</span>
<a name="l01166"></a>01166 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01167"></a>01167 <span class="preprocessor"></span>sub display_format {
<a name="l01168"></a>01168     my $self = shift;
<a name="l01169"></a>01169     my $format = undef;
<a name="l01170"></a>01170 
<a name="l01171"></a>01171     <span class="keywordflow">if</span> (ref $self) {            # Called as a method
<a name="l01172"></a>01172         $format = shift;
<a name="l01173"></a>01173     } <span class="keywordflow">else</span> {                # Regular procedure call
<a name="l01174"></a>01174         $format = $self;
<a name="l01175"></a>01175         undef $self;
<a name="l01176"></a>01176     }
<a name="l01177"></a>01177 
<a name="l01178"></a>01178     <span class="keywordflow">if</span> (defined $self) {
<a name="l01179"></a>01179         <span class="keywordflow">return</span> defined $self-&gt;{display} ? $self-&gt;{display} : $display
<a name="l01180"></a>01180             unless defined $format;
<a name="l01181"></a>01181         <span class="keywordflow">return</span> $self-&gt;{display} = $format;
<a name="l01182"></a>01182     }
<a name="l01183"></a>01183 
<a name="l01184"></a>01184     <span class="keywordflow">return</span> $display unless defined $format;
<a name="l01185"></a>01185     <span class="keywordflow">return</span> $display = $format;
<a name="l01186"></a>01186 }
<a name="l01187"></a>01187 
<a name="l01188"></a>01188 <span class="preprocessor">#</span>
<a name="l01189"></a>01189 <span class="preprocessor"></span><span class="preprocessor"># (stringify)</span>
<a name="l01190"></a>01190 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01191"></a>01191 <span class="preprocessor"></span><span class="preprocessor"># Show nicely formatted complex number under its cartesian or polar form,</span>
<a name="l01192"></a>01192 <span class="preprocessor"></span><span class="preprocessor"># depending on the current display format:</span>
<a name="l01193"></a>01193 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01194"></a>01194 <span class="preprocessor"></span><span class="preprocessor"># . If a specific display format has been recorded for this object, use it.</span>
<a name="l01195"></a>01195 <span class="preprocessor"></span><span class="preprocessor"># . Otherwise, use the generic current default for all complex numbers,</span>
<a name="l01196"></a>01196 <span class="preprocessor"></span><span class="preprocessor">#   which is a package global variable.</span>
<a name="l01197"></a>01197 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01198"></a>01198 <span class="preprocessor"></span>sub stringify {
<a name="l01199"></a>01199     my ($z) = shift;
<a name="l01200"></a>01200     my $format;
<a name="l01201"></a>01201 
<a name="l01202"></a>01202     $format = $display;
<a name="l01203"></a>01203     $format = $z-&gt;{display} <span class="keywordflow">if</span> defined $z-&gt;{display};
<a name="l01204"></a>01204 
<a name="l01205"></a>01205     <span class="keywordflow">return</span> $z-&gt;stringify_polar <span class="keywordflow">if</span> $format =~ /^p/i;
<a name="l01206"></a>01206     <span class="keywordflow">return</span> $z-&gt;stringify_cartesian;
<a name="l01207"></a>01207 }
<a name="l01208"></a>01208 
<a name="l01209"></a>01209 <span class="preprocessor">#</span>
<a name="l01210"></a>01210 <span class="preprocessor"></span><span class="preprocessor"># -&gt;stringify_cartesian</span>
<a name="l01211"></a>01211 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01212"></a>01212 <span class="preprocessor"></span><span class="preprocessor"># Stringify as a cartesian representation &#39;a+bi&#39;.</span>
<a name="l01213"></a>01213 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01214"></a>01214 <span class="preprocessor"></span>sub stringify_cartesian {
<a name="l01215"></a>01215     my $z  = shift;
<a name="l01216"></a>01216     my ($x, $y) = @{$z-&gt;cartesian};
<a name="l01217"></a>01217     my ($re, $im);
<a name="l01218"></a>01218 
<a name="l01219"></a>01219     $x = int($x + ($x &lt; 0 ? -1 : 1) * $eps)
<a name="l01220"></a>01220         if <span class="keywordtype">int</span>(CORE::abs($x)) != <span class="keywordtype">int</span>(CORE::abs($x) + $eps);
<a name="l01221"></a>01221     $y = <span class="keywordtype">int</span>($y + ($y &lt; 0 ? -1 : 1) * $eps)
<a name="l01222"></a>01222         if <span class="keywordtype">int</span>(CORE::abs($y)) != <span class="keywordtype">int</span>(CORE::abs($y) + $eps);
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     $re = &quot;$x&quot; if CORE::abs($x) &gt;= $eps;
<a name="l01225"></a>01225         if ($y == 1)                           { $im = <span class="charliteral">&#39;i&#39;</span> }
<a name="l01226"></a>01226         elsif ($y == -1)                       { $im = <span class="stringliteral">&#39;-i&#39;</span> }
<a name="l01227"></a>01227         elsif (CORE::abs($y) &gt;= $eps)                { $im = $y . <span class="stringliteral">&quot;i&quot;</span> }
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     my $str = <span class="stringliteral">&#39;&#39;</span>;
<a name="l01230"></a>01230     $str = $re <span class="keywordflow">if</span> defined $re;
<a name="l01231"></a>01231     $str .= <span class="stringliteral">&quot;+$im&quot;</span> <span class="keywordflow">if</span> defined $im;
<a name="l01232"></a>01232     $str =~ s/\+-/-/;
<a name="l01233"></a>01233     $str =~ s/^\+<span class="comment">//;</span>
<a name="l01234"></a>01234     $str =~ s/([-+])1i/$1i/; # Not redundant with the above 1/-1 tests.
<a name="l01235"></a>01235     $str = <span class="charliteral">&#39;0&#39;</span> unless $str;
<a name="l01236"></a>01236 
<a name="l01237"></a>01237     <span class="keywordflow">return</span> $str;
<a name="l01238"></a>01238 }
<a name="l01239"></a>01239 
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="preprocessor"># Helper for stringify_polar, a Greatest Common Divisor with a memory.</span>
<a name="l01242"></a>01242 <span class="preprocessor"></span>
<a name="l01243"></a>01243 sub _gcd {
<a name="l01244"></a>01244     my ($a, $b) = @_;
<a name="l01245"></a>01245 
<a name="l01246"></a>01246     use integer;
<a name="l01247"></a>01247 
<a name="l01248"></a>01248 <span class="preprocessor">    # Loops forever if given negative inputs.</span>
<a name="l01249"></a>01249 <span class="preprocessor"></span>
<a name="l01250"></a>01250     <span class="keywordflow">if</span>    ($b and $a &gt; $b) { <span class="keywordflow">return</span> gcd($a % $b, $b) }
<a name="l01251"></a>01251     elsif ($a and $b &gt; $a) { <span class="keywordflow">return</span> gcd($b % $a, $a) }
<a name="l01252"></a>01252     <span class="keywordflow">else</span>                   { <span class="keywordflow">return</span> $a ? $a : $b     }
<a name="l01253"></a>01253 }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255 my %gcd;
<a name="l01256"></a>01256 
<a name="l01257"></a>01257 sub gcd {
<a name="l01258"></a>01258     my ($a, $b) = @_;
<a name="l01259"></a>01259 
<a name="l01260"></a>01260     my $id = <span class="stringliteral">&quot;$a $b&quot;</span>;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     unless (exists $gcd{$id}) {
<a name="l01263"></a>01263     $gcd{$id} = _gcd($a, $b);
<a name="l01264"></a>01264     $gcd{<span class="stringliteral">&quot;$b $a&quot;</span>} = $gcd{$id};
<a name="l01265"></a>01265     }
<a name="l01266"></a>01266 
<a name="l01267"></a>01267     <span class="keywordflow">return</span> $gcd{$id};
<a name="l01268"></a>01268 }
<a name="l01269"></a>01269 
<a name="l01270"></a>01270 <span class="preprocessor">#</span>
<a name="l01271"></a>01271 <span class="preprocessor"></span><span class="preprocessor"># -&gt;stringify_polar</span>
<a name="l01272"></a>01272 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01273"></a>01273 <span class="preprocessor"></span><span class="preprocessor"># Stringify as a polar representation &#39;[r,t]&#39;.</span>
<a name="l01274"></a>01274 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l01275"></a>01275 <span class="preprocessor"></span>sub stringify_polar {
<a name="l01276"></a>01276     my $z  = shift;
<a name="l01277"></a>01277     my ($r, $t) = @{$z-&gt;polar};
<a name="l01278"></a>01278     my $theta;
<a name="l01279"></a>01279 
<a name="l01280"></a>01280     <span class="keywordflow">return</span> <span class="stringliteral">&#39;[0,0]&#39;</span> <span class="keywordflow">if</span> $r &lt;= $eps;
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     my $nt = $t / pit2;
<a name="l01283"></a>01283     $nt = ($nt - int($nt)) * pit2;
<a name="l01284"></a>01284     $nt += pit2 <span class="keywordflow">if</span> $nt &lt; 0;         # Range [0, 2pi]
<a name="l01285"></a>01285 
<a name="l01286"></a>01286     <span class="keywordflow">if</span> (CORE::abs($nt) &lt;= $eps)     { $theta = 0 }
<a name="l01287"></a>01287     elsif (CORE::abs(pi-$nt) &lt;= $eps)   { $theta = <span class="stringliteral">&#39;pi&#39;</span> }
<a name="l01288"></a>01288 
<a name="l01289"></a>01289     <span class="keywordflow">if</span> (defined $theta) {
<a name="l01290"></a>01290         $r = int($r + ($r &lt; 0 ? -1 : 1) * $eps)
<a name="l01291"></a>01291             if <span class="keywordtype">int</span>(CORE::abs($r)) != <span class="keywordtype">int</span>(CORE::abs($r) + $eps);
<a name="l01292"></a>01292         $theta = <span class="keywordtype">int</span>($theta + ($theta &lt; 0 ? -1 : 1) * $eps)
<a name="l01293"></a>01293             if ($theta ne &#39;pi&#39; and
<a name="l01294"></a>01294                 <span class="keywordtype">int</span>(CORE::abs($theta)) != <span class="keywordtype">int</span>(CORE::abs($theta) + $eps));
<a name="l01295"></a>01295         return &quot;\[$r,$theta\]&quot;;
<a name="l01296"></a>01296     }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298     <span class="preprocessor">#</span>
<a name="l01299"></a>01299 <span class="preprocessor"></span><span class="preprocessor">    # Okay, number is not a real. Try to identify pi/n and friends...</span>
<a name="l01300"></a>01300 <span class="preprocessor"></span><span class="preprocessor">    #</span>
<a name="l01301"></a>01301 <span class="preprocessor"></span>
<a name="l01302"></a>01302     $nt -= pit2 <span class="keywordflow">if</span> $nt &gt; pi;
<a name="l01303"></a>01303 
<a name="l01304"></a>01304     <span class="keywordflow">if</span> (CORE::abs($nt) &gt;= deg1) {
<a name="l01305"></a>01305         my ($n, $k, $kpi);
<a name="l01306"></a>01306 
<a name="l01307"></a>01307         <span class="keywordflow">for</span> ($k = 1, $kpi = pi; $k &lt; 10; $k++, $kpi += pi) {
<a name="l01308"></a>01308         $n = int($kpi / $nt + ($nt &gt; 0 ? 1 : -1) * 0.5);
<a name="l01309"></a>01309         <span class="keywordflow">if</span> (CORE::abs($kpi/$n - $nt) &lt;= $eps) {
<a name="l01310"></a>01310             $n = CORE::abs($n);
<a name="l01311"></a>01311             my $gcd = gcd($k, $n);
<a name="l01312"></a>01312             <span class="keywordflow">if</span> ($gcd &gt; 1) {
<a name="l01313"></a>01313             $k /= $gcd;
<a name="l01314"></a>01314             $n /= $gcd;
<a name="l01315"></a>01315             }
<a name="l01316"></a>01316             next <span class="keywordflow">if</span> $n &gt; 360;
<a name="l01317"></a>01317             $theta = ($nt &lt; 0 ? <span class="charliteral">&#39;-&#39;</span>:<span class="stringliteral">&#39;&#39;</span>).
<a name="l01318"></a>01318                  ($k == 1 ? <span class="stringliteral">&#39;pi&#39;</span>:<span class="stringliteral">&quot;${k}pi&quot;</span>);
<a name="l01319"></a>01319             $theta .= <span class="charliteral">&#39;/&#39;</span>.$n <span class="keywordflow">if</span> $n &gt; 1;
<a name="l01320"></a>01320             last;
<a name="l01321"></a>01321         }
<a name="l01322"></a>01322         }
<a name="l01323"></a>01323     }
<a name="l01324"></a>01324 
<a name="l01325"></a>01325     $theta = $nt unless defined $theta;
<a name="l01326"></a>01326 
<a name="l01327"></a>01327     $r = int($r + ($r &lt; 0 ? -1 : 1) * $eps)
<a name="l01328"></a>01328         if <span class="keywordtype">int</span>(CORE::abs($r)) != <span class="keywordtype">int</span>(CORE::abs($r) + $eps);
<a name="l01329"></a>01329     $theta = <span class="keywordtype">int</span>($theta + ($theta &lt; 0 ? -1 : 1) * $eps)
<a name="l01330"></a>01330         if ($theta !~ m(^-?\d*pi/\d+$) and
<a name="l01331"></a>01331             <span class="keywordtype">int</span>(CORE::abs($theta)) != <span class="keywordtype">int</span>(CORE::abs($theta) + $eps));
<a name="l01332"></a>01332 
<a name="l01333"></a>01333     return &quot;\[$r,$theta\]&quot;;
<a name="l01334"></a>01334 }
<a name="l01335"></a>01335 
<a name="l01336"></a>01336 1;
<a name="l01337"></a>01337 __END__
<a name="l01338"></a>01338 
<a name="l01339"></a>01339 =head1 NAME
<a name="l01340"></a>01340 
<a name="l01341"></a>01341 Math::<a class="code" href="classComplex.html">Complex</a> - complex numbers and associated mathematical <a class="code" href="PGstringevaluators_8pl.html#a432234fc3d5710ff4fdc5eacd9a0eae2">functions</a>
<a name="l01342"></a>01342 
<a name="l01343"></a>01343 =head1 SYNOPSIS
<a name="l01344"></a>01344 
<a name="l01345"></a>01345     use Math::<a class="code" href="classComplex.html">Complex</a>;
<a name="l01346"></a>01346 
<a name="l01347"></a>01347     $z = Math::Complex-&gt;make(5, 6);
<a name="l01348"></a>01348     $t = 4 - 3*i + $z;
<a name="l01349"></a>01349     $j = cplxe(1, 2*pi/3);
<a name="l01350"></a>01350 
<a name="l01351"></a>01351 =head1 DESCRIPTION
<a name="l01352"></a>01352 
<a name="l01353"></a>01353 This package lets you create and manipulate complex numbers. By default,
<a name="l01354"></a>01354 I&lt;Perl&gt; limits itself to real numbers, but an extra C&lt;use&gt; statement brings
<a name="l01355"></a>01355 full complex support, along with a full set of mathematical <a class="code" href="PGstringevaluators_8pl.html#a432234fc3d5710ff4fdc5eacd9a0eae2">functions</a>
<a name="l01356"></a>01356 typically associated with and/or extended to complex numbers.
<a name="l01357"></a>01357 
<a name="l01358"></a>01358 If you wonder what complex numbers are, they were invented to be able to solve
<a name="l01359"></a>01359 the following equation:
<a name="l01360"></a>01360 
<a name="l01361"></a>01361     x*x = -1
<a name="l01362"></a>01362 
<a name="l01363"></a>01363 and by definition, the solution is noted I&lt;i&gt; (engineers use I&lt;j&gt; instead since
<a name="l01364"></a>01364 I&lt;i&gt; usually denotes an intensity, but the name does not matter). The number
<a name="l01365"></a>01365 I&lt;i&gt; is a pure I&lt;imaginary&gt; number.
<a name="l01366"></a>01366 
<a name="l01367"></a>01367 The arithmetics with pure imaginary numbers works just like you would expect
<a name="l01368"></a>01368 it with real numbers... you just have to remember that
<a name="l01369"></a>01369 
<a name="l01370"></a>01370     i*i = -1
<a name="l01371"></a>01371 
<a name="l01372"></a>01372 so you have:
<a name="l01373"></a>01373 
<a name="l01374"></a>01374     5i + 7i = i * (5 + 7) = 12i
<a name="l01375"></a>01375     4i - 3i = i * (4 - 3) = i
<a name="l01376"></a>01376     4i * 2i = -8
<a name="l01377"></a>01377     6i / 2i = 3
<a name="l01378"></a>01378     1 / i = -i
<a name="l01379"></a>01379 
<a name="l01380"></a>01380 Complex numbers are numbers that have both a real part and an imaginary
<a name="l01381"></a>01381 part, and are usually noted:
<a name="l01382"></a>01382 
<a name="l01383"></a>01383     a + bi
<a name="l01384"></a>01384 
<a name="l01385"></a>01385 where C&lt;a&gt; is the I&lt;real&gt; part and C&lt;b&gt; is the I&lt;imaginary&gt; part. The
<a name="l01386"></a>01386 arithmetic with complex numbers is straightforward. You have to
<a name="l01387"></a>01387 keep track of the real and the imaginary parts, but otherwise the
<a name="l01388"></a>01388 rules used for real numbers just apply:
<a name="l01389"></a>01389 
<a name="l01390"></a>01390     (4 + 3i) + (5 - 2i) = (4 + 5) + i(3 - 2) = 9 + i
<a name="l01391"></a>01391     (2 + i) * (4 - i) = 2*4 + 4i -2i -i*i = 8 + 2i + 1 = 9 + 2i
<a name="l01392"></a>01392 
<a name="l01393"></a>01393 A graphical representation of complex numbers is possible in a plane
<a name="l01394"></a>01394 (also called the I&lt;complex plane&gt;, but it&#39;s really a 2D plane).
<a name="l01395"></a>01395 The number
<a name="l01396"></a>01396 
<a name="l01397"></a>01397     z = a + bi
<a name="l01398"></a>01398 
<a name="l01399"></a>01399 is the point whose coordinates are (a, b). Actually, it would
<a name="l01400"></a>01400 be the vector originating from (0, 0) to (a, b). It follows that the addition
<a name="l01401"></a>01401 of two complex numbers is a vectorial addition.
<a name="l01402"></a>01402 
<a name="l01403"></a>01403 Since there is a bijection between a point in the 2D plane and a complex
<a name="l01404"></a>01404 number (i.e. the mapping is unique and reciprocal), a complex number
<a name="l01405"></a>01405 can also be uniquely identified with polar coordinates:
<a name="l01406"></a>01406 
<a name="l01407"></a>01407     [rho, theta]
<a name="l01408"></a>01408 
<a name="l01409"></a>01409 where C&lt;rho&gt; is the distance to the origin, and C&lt;theta&gt; the angle between
<a name="l01410"></a>01410 the vector and the I&lt;x&gt; axis. There is a notation for this using the
<a name="l01411"></a>01411 exponential form, which is:
<a name="l01412"></a>01412 
<a name="l01413"></a>01413     rho * exp(i * theta)
<a name="l01414"></a>01414 
<a name="l01415"></a>01415 where I&lt;i&gt; is the famous imaginary number introduced above. Conversion
<a name="l01416"></a>01416 between this form and the cartesian form C&lt;a + bi&gt; is immediate:
<a name="l01417"></a>01417 
<a name="l01418"></a>01418     a = rho * cos(theta)
<a name="l01419"></a>01419     b = rho * sin(theta)
<a name="l01420"></a>01420 
<a name="l01421"></a>01421 which is also expressed by this formula:
<a name="l01422"></a>01422 
<a name="l01423"></a>01423     z = rho * exp(i * theta) = rho * (cos theta + i * sin theta)
<a name="l01424"></a>01424 
<a name="l01425"></a>01425 In other words, it&#39;s the projection of the vector onto the I&lt;x&gt; and I&lt;y&gt;
<a name="l01426"></a>01426 axes. Mathematicians call I&lt;rho&gt; the I&lt;norm&gt; or I&lt;modulus&gt; and I&lt;theta&gt;
<a name="l01427"></a>01427 the I&lt;argument&gt; of the complex number. The I&lt;norm&gt; of C&lt;z&gt; will be
<a name="l01428"></a>01428 noted C&lt;abs(z)&gt;.
<a name="l01429"></a>01429 
<a name="l01430"></a>01430 The polar notation (also known as the trigonometric
<a name="l01431"></a>01431 representation) is much more handy for performing multiplications and
<a name="l01432"></a>01432 divisions of complex numbers, whilst the cartesian notation is better
<a name="l01433"></a>01433 suited for additions and subtractions. Real numbers are on the I&lt;x&gt;
<a name="l01434"></a>01434 axis, and therefore I&lt;theta&gt; is zero or I&lt;pi&gt;.
<a name="l01435"></a>01435 
<a name="l01436"></a>01436 All the common operations that can be performed on a real number have
<a name="l01437"></a>01437 been defined to work on complex numbers as well, and are merely
<a name="l01438"></a>01438 I&lt;extensions&gt; of the operations defined on real numbers. This means
<a name="l01439"></a>01439 they keep their natural meaning when there is no imaginary part, provided
<a name="l01440"></a>01440 the number is within their definition set.
<a name="l01441"></a>01441 
<a name="l01442"></a>01442 For instance, the C&lt;sqrt&gt; routine which computes the square root of
<a name="l01443"></a>01443 its argument is only defined for non-negative real numbers and yields a
<a name="l01444"></a>01444 non-negative real number (it is an application from B&lt;R+&gt; to B&lt;R+&gt;).
<a name="l01445"></a>01445 If we allow it to return a complex number, then it can be extended to
<a name="l01446"></a>01446 negative real numbers to become an application from B&lt;R&gt; to B&lt;C&gt; (the
<a name="l01447"></a>01447 set of complex numbers):
<a name="l01448"></a>01448 
<a name="l01449"></a>01449     sqrt(x) = x &gt;= 0 ? sqrt(x) : sqrt(-x)*i
<a name="l01450"></a>01450 
<a name="l01451"></a>01451 It can also be extended to be an application from B&lt;C&gt; to B&lt;C&gt;,
<a name="l01452"></a>01452 whilst its restriction to B&lt;R&gt; behaves as defined above by using
<a name="l01453"></a>01453 the following definition:
<a name="l01454"></a>01454 
<a name="l01455"></a>01455     sqrt(z = [r,t]) = sqrt(r) * exp(i * t/2)
<a name="l01456"></a>01456 
<a name="l01457"></a>01457 Indeed, a negative real number can be noted C&lt;[x,pi]&gt; (the modulus
<a name="l01458"></a>01458 I&lt;x&gt; is always non-negative, so C&lt;[x,pi]&gt; is really C&lt;-x&gt;, a negative
<a name="l01459"></a>01459 number) and the above definition states that
<a name="l01460"></a>01460 
<a name="l01461"></a>01461     sqrt([x,pi]) = sqrt(x) * exp(i*pi/2) = [sqrt(x),pi/2] = sqrt(x)*i
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 which is exactly what we had defined for negative real numbers above.
<a name="l01464"></a>01464 The C&lt;sqrt&gt; returns only one of the solutions: if you want the both,
<a name="l01465"></a>01465 use the C&lt;root&gt; function.
<a name="l01466"></a>01466 
<a name="l01467"></a>01467 All the common mathematical <a class="code" href="PGstringevaluators_8pl.html#a432234fc3d5710ff4fdc5eacd9a0eae2">functions</a> defined on real numbers that
<a name="l01468"></a>01468 are extended to complex numbers share that same property of working
<a name="l01469"></a>01469 I&lt;as usual&gt; when the imaginary part is zero (otherwise, it would not
<a name="l01470"></a>01470 be called an extension, would it?).
<a name="l01471"></a>01471 
<a name="l01472"></a>01472 A I&lt;new&gt; operation possible on a complex number that is
<a name="l01473"></a>01473 the identity for real numbers is called the I&lt;conjugate&gt;, and is noted
<a name="l01474"></a>01474 with an horizontal bar above the number, or C&lt;~z&gt; here.
<a name="l01475"></a>01475 
<a name="l01476"></a>01476      z = a + bi
<a name="l01477"></a>01477     ~z = a - bi
<a name="l01478"></a>01478 
<a name="l01479"></a>01479 Simple... Now look:
<a name="l01480"></a>01480 
<a name="l01481"></a>01481     z * ~z = (a + bi) * (a - bi) = a*a + b*b
<a name="l01482"></a>01482 
<a name="l01483"></a>01483 We saw that the norm of C&lt;z&gt; was noted C&lt;abs(z)&gt; and was defined as the
<a name="l01484"></a>01484 distance to the origin, also known as:
<a name="l01485"></a>01485 
<a name="l01486"></a>01486     rho = abs(z) = sqrt(a*a + b*b)
<a name="l01487"></a>01487 
<a name="l01488"></a>01488 so
<a name="l01489"></a>01489 
<a name="l01490"></a>01490     z * ~z = abs(z) ** 2
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 If z is a pure real number (i.e. C&lt;b == 0&gt;), then the above yields:
<a name="l01493"></a>01493 
<a name="l01494"></a>01494     a * a = abs(a) ** 2
<a name="l01495"></a>01495 
<a name="l01496"></a>01496 which is true (C&lt;abs&gt; has the regular meaning for real number, i.e. stands
<a name="l01497"></a>01497 for the absolute value). This example explains why the norm of C&lt;z&gt; is
<a name="l01498"></a>01498 noted C&lt;abs(z)&gt;: it extends the C&lt;abs&gt; function to complex numbers, yet
<a name="l01499"></a>01499 is the regular C&lt;abs&gt; we know when the complex number actually has no
<a name="l01500"></a>01500 imaginary part... This justifies I&lt;a posteriori&gt; our use of the C&lt;abs&gt;
<a name="l01501"></a>01501 notation for the norm.
<a name="l01502"></a>01502 
<a name="l01503"></a>01503 =head1 OPERATIONS
<a name="l01504"></a>01504 
<a name="l01505"></a>01505 Given the following notations:
<a name="l01506"></a>01506 
<a name="l01507"></a>01507     z1 = a + bi = r1 * exp(i * t1)
<a name="l01508"></a>01508     z2 = c + di = r2 * exp(i * t2)
<a name="l01509"></a>01509     z = &lt;any complex or real number&gt;
<a name="l01510"></a>01510 
<a name="l01511"></a>01511 the following (overloaded) operations are supported on complex numbers:
<a name="l01512"></a>01512 
<a name="l01513"></a>01513     z1 + z2 = (a + c) + i(b + d)
<a name="l01514"></a>01514     z1 - z2 = (a - c) + i(b - d)
<a name="l01515"></a>01515     z1 * z2 = (r1 * r2) * exp(i * (t1 + t2))
<a name="l01516"></a>01516     z1 / z2 = (r1 / r2) * exp(i * (t1 - t2))
<a name="l01517"></a>01517     z1 ** z2 = exp(z2 * log z1)
<a name="l01518"></a>01518     ~z = a - bi
<a name="l01519"></a>01519     abs(z) = r1 = sqrt(a*a + b*b)
<a name="l01520"></a>01520     sqrt(z) = sqrt(r1) * exp(i * t/2)
<a name="l01521"></a>01521     exp(z) = exp(a) * exp(i * b)
<a name="l01522"></a>01522     log(z) = log(r1) + i*t
<a name="l01523"></a>01523     sin(z) = 1/2i (exp(i * z1) - exp(-i * z))
<a name="l01524"></a>01524     cos(z) = 1/2 (exp(i * z1) + exp(-i * z))
<a name="l01525"></a>01525     atan2(z1, z2) = atan(z1/z2)
<a name="l01526"></a>01526 
<a name="l01527"></a>01527 The following extra operations are supported on both real and complex
<a name="l01528"></a>01528 numbers:
<a name="l01529"></a>01529 
<a name="l01530"></a>01530     Re(z) = a
<a name="l01531"></a>01531     Im(z) = b
<a name="l01532"></a>01532     arg(z) = t
<a name="l01533"></a>01533     abs(z) = r
<a name="l01534"></a>01534 
<a name="l01535"></a>01535     cbrt(z) = z ** (1/3)
<a name="l01536"></a>01536     log10(z) = log(z) / log(10)
<a name="l01537"></a>01537     logn(z, n) = log(z) / log(n)
<a name="l01538"></a>01538 
<a name="l01539"></a>01539     tan(z) = sin(z) / cos(z)
<a name="l01540"></a>01540 
<a name="l01541"></a>01541     csc(z) = 1 / sin(z)
<a name="l01542"></a>01542     sec(z) = 1 / cos(z)
<a name="l01543"></a>01543     cot(z) = 1 / tan(z)
<a name="l01544"></a>01544 
<a name="l01545"></a>01545     asin(z) = -i * log(i*z + sqrt(1-z*z))
<a name="l01546"></a>01546     acos(z) = -i * log(z + i*sqrt(1-z*z))
<a name="l01547"></a>01547     atan(z) = i/2 * log((i+z) / (i-z))
<a name="l01548"></a>01548 
<a name="l01549"></a>01549     acsc(z) = asin(1 / z)
<a name="l01550"></a>01550     asec(z) = acos(1 / z)
<a name="l01551"></a>01551     acot(z) = atan(1 / z) = -i/2 * log((i+z) / (z-i))
<a name="l01552"></a>01552 
<a name="l01553"></a>01553     sinh(z) = 1/2 (exp(z) - exp(-z))
<a name="l01554"></a>01554     cosh(z) = 1/2 (exp(z) + exp(-z))
<a name="l01555"></a>01555     tanh(z) = sinh(z) / cosh(z) = (exp(z) - exp(-z)) / (exp(z) + exp(-z))
<a name="l01556"></a>01556 
<a name="l01557"></a>01557     csch(z) = 1 / sinh(z)
<a name="l01558"></a>01558     sech(z) = 1 / cosh(z)
<a name="l01559"></a>01559     coth(z) = 1 / tanh(z)
<a name="l01560"></a>01560 
<a name="l01561"></a>01561     asinh(z) = log(z + sqrt(z*z+1))
<a name="l01562"></a>01562     acosh(z) = log(z + sqrt(z*z-1))
<a name="l01563"></a>01563     atanh(z) = 1/2 * log((1+z) / (1-z))
<a name="l01564"></a>01564 
<a name="l01565"></a>01565     acsch(z) = asinh(1 / z)
<a name="l01566"></a>01566     asech(z) = acosh(1 / z)
<a name="l01567"></a>01567     acoth(z) = atanh(1 / z) = 1/2 * log((1+z) / (z-1))
<a name="l01568"></a>01568 
<a name="l01569"></a>01569 I&lt;arg&gt;, I&lt;abs&gt;, I&lt;log&gt;, I&lt;csc&gt;, I&lt;cot&gt;, I&lt;acsc&gt;, I&lt;acot&gt;, I&lt;csch&gt;,
<a name="l01570"></a>01570 I&lt;coth&gt;, I&lt;acosech&gt;, I&lt;acotanh&gt;, have aliases I&lt;rho&gt;, I&lt;theta&gt;, I&lt;ln&gt;,
<a name="l01571"></a>01571 I&lt;cosec&gt;, I&lt;cotan&gt;, I&lt;acosec&gt;, I&lt;acotan&gt;, I&lt;cosech&gt;, I&lt;cotanh&gt;,
<a name="l01572"></a>01572 I&lt;acosech&gt;, I&lt;acotanh&gt;, respectively.  C&lt;Re&gt;, C&lt;Im&gt;, C&lt;arg&gt;, C&lt;abs&gt;,
<a name="l01573"></a>01573 C&lt;rho&gt;, and C&lt;theta&gt; can be used also also mutators.  The C&lt;cbrt&gt;
<a name="l01574"></a>01574 returns only one of the solutions: if you want all three, use the
<a name="l01575"></a>01575 C&lt;root&gt; function.
<a name="l01576"></a>01576 
<a name="l01577"></a>01577 The I&lt;root&gt; function is available to compute all the I&lt;n&gt;
<a name="l01578"></a>01578 roots of some complex, where I&lt;n&gt; is a strictly positive integer.
<a name="l01579"></a>01579 There are exactly I&lt;n&gt; such roots, returned as a list. Getting the
<a name="l01580"></a>01580 number mathematicians call C&lt;j&gt; such that:
<a name="l01581"></a>01581 
<a name="l01582"></a>01582     1 + j + j*j = 0;
<a name="l01583"></a>01583 
<a name="l01584"></a>01584 is a simple matter of writing:
<a name="l01585"></a>01585 
<a name="l01586"></a>01586     $j = ((root(1, 3))[1];
<a name="l01587"></a>01587 
<a name="l01588"></a>01588 The I&lt;k&gt;th root for C&lt;z = [r,t]&gt; is given by:
<a name="l01589"></a>01589 
<a name="l01590"></a>01590     (root(z, n))[k] = r**(1/n) * exp(i * (t + 2*k*pi)/n)
<a name="l01591"></a>01591 
<a name="l01592"></a>01592 The I&lt;spaceship&gt; comparison operator, E&lt;lt&gt;=E&lt;gt&gt;, is also defined. In
<a name="l01593"></a>01593 order to ensure its restriction to real numbers is conform to what you
<a name="l01594"></a>01594 would expect, the comparison is run on the real part of the complex
<a name="l01595"></a>01595 number first, and imaginary parts are compared only when the real
<a name="l01596"></a>01596 parts match.
<a name="l01597"></a>01597 
<a name="l01598"></a>01598 =head1 CREATION
<a name="l01599"></a>01599 
<a name="l01600"></a>01600 To create a complex number, use either:
<a name="l01601"></a>01601 
<a name="l01602"></a>01602     $z = Math::Complex-&gt;make(3, 4);
<a name="l01603"></a>01603     $z = cplx(3, 4);
<a name="l01604"></a>01604 
<a name="l01605"></a>01605 if you know the cartesian form of the number, or
<a name="l01606"></a>01606 
<a name="l01607"></a>01607     $z = 3 + 4*i;
<a name="l01608"></a>01608 
<a name="l01609"></a>01609 if you like. To create a number using the polar form, use either:
<a name="l01610"></a>01610 
<a name="l01611"></a>01611     $z = Math::Complex-&gt;emake(5, pi/3);
<a name="l01612"></a>01612     $x = cplxe(5, pi/3);
<a name="l01613"></a>01613 
<a name="l01614"></a>01614 instead. The first argument is the modulus, the second is the angle
<a name="l01615"></a>01615 (in radians, the full circle is 2*pi).  (Mnemonic: C&lt;e&gt; is used as a
<a name="l01616"></a>01616 notation for complex numbers in the polar form).
<a name="l01617"></a>01617 
<a name="l01618"></a>01618 It is possible to write:
<a name="l01619"></a>01619 
<a name="l01620"></a>01620     $x = cplxe(-3, pi/4);
<a name="l01621"></a>01621 
<a name="l01622"></a>01622 but that will be silently converted into C&lt;[3,-3pi/4]&gt;, since the modulus
<a name="l01623"></a>01623 must be non-negative (it represents the distance to the origin in the complex
<a name="l01624"></a>01624 plane).
<a name="l01625"></a>01625 
<a name="l01626"></a>01626 It is also possible to have a complex number as either argument of
<a name="l01627"></a>01627 either the C&lt;make&gt; or C&lt;emake&gt;: the appropriate component of
<a name="l01628"></a>01628 the argument will be used.
<a name="l01629"></a>01629 
<a name="l01630"></a>01630     $z1 = cplx(-2,  1);
<a name="l01631"></a>01631     $z2 = cplx($z1, 4);
<a name="l01632"></a>01632 
<a name="l01633"></a>01633 =head1 STRINGIFICATION
<a name="l01634"></a>01634 
<a name="l01635"></a>01635 When printed, a complex number is usually shown under its cartesian
<a name="l01636"></a>01636 form I&lt;a+bi&gt;, but there are legitimate cases where the polar format
<a name="l01637"></a>01637 I&lt;[r,t]&gt; is more appropriate.
<a name="l01638"></a>01638 
<a name="l01639"></a>01639 By calling the routine C&lt;<a class="code" href="classComplex1.html">Complex1</a>::display_format&gt; and supplying either
<a name="l01640"></a>01640 C&lt;&quot;polar&quot;&gt; or C&lt;&quot;cartesian&quot;&gt;, you override the default display format,
<a name="l01641"></a>01641 which is C&lt;&quot;cartesian&quot;&gt;. Not supplying any argument returns the current
<a name="l01642"></a>01642 setting.
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 This default can be overridden on a per-number basis by calling the
<a name="l01645"></a>01645 C&lt;display_format&gt; method instead. As before, not supplying any argument
<a name="l01646"></a>01646 returns the current display format for this number. Otherwise whatever you
<a name="l01647"></a>01647 specify will be the new display format for I&lt;this&gt; particular number.
<a name="l01648"></a>01648 
<a name="l01649"></a>01649 For instance:
<a name="l01650"></a>01650 
<a name="l01651"></a>01651     use Math::Complex;
<a name="l01652"></a>01652 
<a name="l01653"></a>01653     <a class="code" href="classComplex1.html">Complex1</a>::display_format(&#39;polar&#39;);
<a name="l01654"></a>01654     $j = ((root(1, 3))[1];
<a name="l01655"></a>01655     print &quot;j = $j\n&quot;;       <span class="preprocessor"># Prints &quot;j = [1,2pi/3]</span>
<a name="l01656"></a>01656 <span class="preprocessor"></span>    $j-&gt;display_format(<span class="stringliteral">&#39;cartesian&#39;</span>);
<a name="l01657"></a>01657     print <span class="stringliteral">&quot;j = $j\n&quot;</span>;       # Prints <span class="stringliteral">&quot;j = -0.5+0.866025403784439i&quot;</span>
<a name="l01658"></a>01658 
<a name="l01659"></a>01659 The polar format attempts to emphasize arguments like I&lt;k*pi/n&gt;
<a name="l01660"></a>01660 (where I&lt;n&gt; is a positive integer and I&lt;k&gt; an integer within [-9,+9]).
<a name="l01661"></a>01661 
<a name="l01662"></a>01662 =head1 USAGE
<a name="l01663"></a>01663 
<a name="l01664"></a>01664 Thanks to overloading, the handling of arithmetics with complex numbers
<a name="l01665"></a>01665 is simple and almost transparent.
<a name="l01666"></a>01666 
<a name="l01667"></a>01667 Here are some examples:
<a name="l01668"></a>01668 
<a name="l01669"></a>01669     use Math::Complex;
<a name="l01670"></a>01670 
<a name="l01671"></a>01671     $j = cplxe(1, 2*pi/3);  # $j ** 3 == 1
<a name="l01672"></a>01672     print <span class="stringliteral">&quot;j = $j, j**3 = &quot;</span>, $j ** 3, <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01673"></a>01673     print <span class="stringliteral">&quot;1 + j + j**2 = &quot;</span>, 1 + $j + $j**2, <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01674"></a>01674 
<a name="l01675"></a>01675     $z = -16 + 0*i;         # Force it to be a complex
<a name="l01676"></a>01676     print <span class="stringliteral">&quot;sqrt($z) = &quot;</span>, sqrt($z), <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01677"></a>01677 
<a name="l01678"></a>01678     $k = exp(i * 2*pi/3);
<a name="l01679"></a>01679     print <span class="stringliteral">&quot;$j - $k = &quot;</span>, $j - $k, <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01680"></a>01680 
<a name="l01681"></a>01681     $z-&gt;Re(3);          # Re, Im, arg, abs,
<a name="l01682"></a>01682     $j-&gt;arg(2);         # (the last two aka rho, theta)
<a name="l01683"></a>01683                     # can be used also as mutators.
<a name="l01684"></a>01684 
<a name="l01685"></a>01685 =head1 ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 The division (/) and the following <a class="code" href="PGstringevaluators_8pl.html#a432234fc3d5710ff4fdc5eacd9a0eae2">functions</a>
<a name="l01688"></a>01688 
<a name="l01689"></a>01689     log ln  log10   logn
<a name="l01690"></a>01690     tan sec csc cot
<a name="l01691"></a>01691     atan    asec    acsc    acot
<a name="l01692"></a>01692     tanh    sech    csch    coth
<a name="l01693"></a>01693     atanh   asech   acsch   acoth
<a name="l01694"></a>01694 
<a name="l01695"></a>01695 cannot be computed <span class="keywordflow">for</span> all arguments because that would mean dividing
<a name="l01696"></a>01696 by zero or taking logarithm of zero. These situations cause fatal
<a name="l01697"></a>01697 runtime errors looking like <span class="keyword">this</span>
<a name="l01698"></a>01698 
<a name="l01699"></a>01699     cot(0): Division by zero.
<a name="l01700"></a>01700     (Because in the definition of cot(0), the divisor sin(0) is 0)
<a name="l01701"></a>01701     Died at ...
<a name="l01702"></a>01702 
<a name="l01703"></a>01703 or
<a name="l01704"></a>01704 
<a name="l01705"></a>01705     atanh(-1): Logarithm of zero.
<a name="l01706"></a>01706     Died at...
<a name="l01707"></a>01707 
<a name="l01708"></a>01708 For the C&lt;csc&gt;, C&lt;cot&gt;, C&lt;asec&gt;, C&lt;acsc&gt;, C&lt;acot&gt;, C&lt;csch&gt;, C&lt;coth&gt;,
<a name="l01709"></a>01709 C&lt;asech&gt;, C&lt;acsch&gt;, the argument cannot be C&lt;0&gt; (zero).  For the the
<a name="l01710"></a>01710 logarithmic <a class="code" href="PGstringevaluators_8pl.html#a432234fc3d5710ff4fdc5eacd9a0eae2">functions</a> and the C&lt;atanh&gt;, C&lt;acoth&gt;, the argument cannot
<a name="l01711"></a>01711 be C&lt;1&gt; (one).  For the C&lt;atanh&gt;, C&lt;acoth&gt;, the argument cannot be
<a name="l01712"></a>01712 C&lt;-1&gt; (minus one).  For the C&lt;atan&gt;, C&lt;acot&gt;, the argument cannot be
<a name="l01713"></a>01713 C&lt;i&gt; (the imaginary unit).  For the C&lt;atan&gt;, C&lt;acoth&gt;, the argument
<a name="l01714"></a>01714 cannot be C&lt;-i&gt; (the negative imaginary unit).  For the C&lt;tan&gt;,
<a name="l01715"></a>01715 C&lt;sec&gt;, C&lt;tanh&gt;, the argument cannot be I&lt;pi/2 + k * pi&gt;, where I&lt;k&gt;
<a name="l01716"></a>01716 is any integer.
<a name="l01717"></a>01717 
<a name="l01718"></a>01718 Note that because we are operating on approximations of real numbers,
<a name="l01719"></a>01719 these errors can happen when merely `too close<span class="stringliteral">&#39; to the singularities</span>
<a name="l01720"></a>01720 <span class="stringliteral">listed above.  For example C&lt;tan(2*atan2(1,1)+1e-15)&gt; will die of</span>
<a name="l01721"></a>01721 <span class="stringliteral">division by zero.</span>
<a name="l01722"></a>01722 <span class="stringliteral"></span>
<a name="l01723"></a>01723 <span class="stringliteral">=head1 ERRORS DUE TO INDIGESTIBLE ARGUMENTS</span>
<a name="l01724"></a>01724 <span class="stringliteral"></span>
<a name="l01725"></a>01725 <span class="stringliteral">The C&lt;make&gt; and C&lt;emake&gt; accept both real and complex arguments.</span>
<a name="l01726"></a>01726 <span class="stringliteral">When they cannot recognize the arguments they will die with error</span>
<a name="l01727"></a>01727 <span class="stringliteral">messages like the following</span>
<a name="l01728"></a>01728 <span class="stringliteral"></span>
<a name="l01729"></a>01729 <span class="stringliteral">    Complex1::make: Cannot take real part of ...</span>
<a name="l01730"></a>01730 <span class="stringliteral">    Complex1::make: Cannot take real part of ...</span>
<a name="l01731"></a>01731 <span class="stringliteral">    Complex1::emake: Cannot take rho of ...</span>
<a name="l01732"></a>01732 <span class="stringliteral">    Complex1::emake: Cannot take theta of ...</span>
<a name="l01733"></a>01733 <span class="stringliteral"></span>
<a name="l01734"></a>01734 <span class="stringliteral">=head1 BUGS</span>
<a name="l01735"></a>01735 <span class="stringliteral"></span>
<a name="l01736"></a>01736 <span class="stringliteral">Saying C&lt;use Math::Complex;&gt; exports many mathematical routines in the</span>
<a name="l01737"></a>01737 <span class="stringliteral">caller environment and even overrides some (C&lt;sqrt&gt;, C&lt;log&gt;).</span>
<a name="l01738"></a>01738 <span class="stringliteral">This is construed as a feature by the Authors, actually... ;-)</span>
<a name="l01739"></a>01739 <span class="stringliteral"></span>
<a name="l01740"></a>01740 <span class="stringliteral">All routines expect to be given real or complex numbers. Don&#39;</span>t attempt to
<a name="l01741"></a>01741 use BigFloat, since Perl has currently no rule to disambiguate a <span class="stringliteral">&#39;+&#39;</span>
<a name="l01742"></a>01742 operation (for instance) between two overloaded entities.
<a name="l01743"></a>01743 
<a name="l01744"></a>01744 In Cray UNICOS there is some strange numerical instability that results
<a name="l01745"></a>01745 in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast.  Beware.
<a name="l01746"></a>01746 The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex.
<a name="l01747"></a>01747 Whatever it is, it does not manifest itself anywhere else where Perl runs.
<a name="l01748"></a>01748 
<a name="l01749"></a>01749 =head1 AUTHORS
<a name="l01750"></a>01750 
<a name="l01751"></a>01751 Raphael Manfredi &lt;F&lt;Raphael_Manfredi@grenoble.hp.com&gt;&gt; and
<a name="l01752"></a>01752 Jarkko Hietaniemi &lt;F&lt;jhi@iki.fi&gt;&gt;.
<a name="l01753"></a>01753 
<a name="l01754"></a>01754 Extensive patches by Daniel S. Lewart &lt;F&lt;d-lewart@uiuc.edu&gt;&gt;.
<a name="l01755"></a>01755 
<a name="l01756"></a>01756 =cut
<a name="l01757"></a>01757 
<a name="l01758"></a>01758 1;
<a name="l01759"></a>01759 
<a name="l01760"></a>01760 <span class="preprocessor"># eof</span>
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Jun 8 22:54:54 2012 for PG by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
