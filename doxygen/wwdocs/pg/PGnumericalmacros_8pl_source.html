<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PG: PGnumericalmacros.pl Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>PGnumericalmacros.pl</h1><a href="PGnumericalmacros_8pl.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="preprocessor">#use strict;</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">###########</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span><span class="preprocessor">#use Carp;</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span>
<a name="l00007"></a>00007 =head1 NAME
<a name="l00008"></a>00008 
<a name="l00009"></a>00009     Numerical methods <span class="keywordflow">for</span> the <a class="code" href="classWeBWorK_1_1PG.html">PG</a> language
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 =head1 SYNPOSIS
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 =head1 DESCRIPTION
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 =cut
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 =head2 Interpolation  methods
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 =head3 Plotting a list of points (piecewise linear interpolation)
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 
<a name="l00024"></a>00024     Usage:  plot_list([x0,y0,x1,y1,...]);
<a name="l00025"></a>00025             plot_list([(x0,y0),(x1,y1),...]);
<a name="l00026"></a>00026             plot_list(\x_y_array);
<a name="l00027"></a>00027 
<a name="l00028"></a>00028             plot_list([x0,x1,x2...], [y0,y1,y2,...]);
<a name="l00029"></a>00029             plot_list(\@xarray,\@yarray);
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 =cut
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 BEGIN {
<a name="l00035"></a>00035     be_strict();
<a name="l00036"></a>00036 }
<a name="l00037"></a>00037 sub _PGnumericalmacros_init {
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 sub plot_list {
<a name="l00041"></a>00041     my($xref,$yref) = @_;
<a name="l00042"></a>00042     unless( defined($xref) &amp;&amp; ref($xref) =~/ARRAY/  ) {
<a name="l00043"></a>00043         die <span class="stringliteral">&quot;Error in plot_list:X values must be given as an array reference.</span>
<a name="l00044"></a>00044 <span class="stringliteral">         Remember to use ~~\@array to reference an array in the PG language.&quot;</span>;
<a name="l00045"></a>00045     }
<a name="l00046"></a>00046     <span class="keywordflow">if</span> (defined($yref) &amp;&amp; ! ( ref($yref) =~/ARRAY/ ) ) {
<a name="l00047"></a>00047         die <span class="stringliteral">&quot;Error in plot_list:Y values must be given as an array reference.</span>
<a name="l00048"></a>00048 <span class="stringliteral">         Remember to use ~~\@array to reference an array in the PG language.&quot;</span>;
<a name="l00049"></a>00049     }
<a name="l00050"></a>00050     my (@x_vals, @y_vals);
<a name="l00051"></a>00051     unless( defined($yref) ) { #with only one entry we assume (x0,y0,x1,y1..);
<a name="l00052"></a>00052         <span class="keywordflow">if</span> ( @$xref % 2 ==1) {
<a name="l00053"></a>00053             die <span class="stringliteral">&quot;ERROR in plot_list -- single array of input has odd number of</span>
<a name="l00054"></a>00054 <span class="stringliteral">            elements&quot;</span>;
<a name="l00055"></a>00055         }
<a name="l00056"></a>00056 
<a name="l00057"></a>00057        my  @in = @$xref;
<a name="l00058"></a>00058        <span class="keywordflow">while</span> (@in) {
<a name="l00059"></a>00059             push(@x_vals, shift(@in));
<a name="l00060"></a>00060             push(@y_vals, shift(@in));
<a name="l00061"></a>00061         }
<a name="l00062"></a>00062         $xref = \@x_vals;
<a name="l00063"></a>00063         $yref = \@y_vals;
<a name="l00064"></a>00064     }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066     my $fun =sub {
<a name="l00067"></a>00067         my $x = shift;
<a name="l00068"></a>00068         my $y;
<a name="l00069"></a>00069         my( $x0,$x1,$y0,$y1);
<a name="l00070"></a>00070         my @x_values = @$xref;
<a name="l00071"></a>00071         my @y_values = @$yref;
<a name="l00072"></a>00072         <span class="keywordflow">while</span> (( @x_values and $x &gt; $x_values[0]) or
<a name="l00073"></a>00073                ( @x_values &gt; 0 and $x &gt;= $x_values[0] ) ) {
<a name="l00074"></a>00074             $x0 = shift(@x_values);
<a name="l00075"></a>00075             $y0 = shift(@y_values);
<a name="l00076"></a>00076         }
<a name="l00077"></a>00077 <span class="preprocessor">        # now that we have the left hand of the input</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">        #check first that x isn&#39;t out of range to the left or right</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (@x_values  &amp;&amp; defined($x0) )  {
<a name="l00080"></a>00080             $x1= shift(@x_values);
<a name="l00081"></a>00081             $y1=shift(@y_values);
<a name="l00082"></a>00082             $y = $y0 + ($y1-$y0)*($x-$x0)/($x1-$x0);
<a name="l00083"></a>00083         }
<a name="l00084"></a>00084         $y;
<a name="l00085"></a>00085     };
<a name="l00086"></a>00086     $fun;
<a name="l00087"></a>00087 }
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 =head3 Horner polynomial/ Newton polynomial
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     Usege:  $fn = horner([x0,x1,x2],[q0,q1,q2]);
<a name="l00094"></a>00094         Produces the newton polynomial
<a name="l00095"></a>00095         &amp;$fn(x) = q0 + q1*(x-x0) +q2*(x-x1)*(x-x0);
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 Generates a subroutine which evaluates a polynomial passing through the points C&lt;(x0,q0), (x1,q1),
<a name="l00098"></a>00098 ... &gt; <span class="keyword">using</span> Horner<span class="stringliteral">&#39;s method.</span>
<a name="l00099"></a>00099 <span class="stringliteral"></span>
<a name="l00100"></a>00100 <span class="stringliteral">=cut</span>
<a name="l00101"></a>00101 <span class="stringliteral"></span>
<a name="l00102"></a>00102 <span class="stringliteral">sub horner {</span>
<a name="l00103"></a>00103 <span class="stringliteral">    my ($xref,$qref) = @_;  # get the coefficients</span>
<a name="l00104"></a>00104 <span class="stringliteral">    my $fn = sub {</span>
<a name="l00105"></a>00105 <span class="stringliteral">        my $x = shift;</span>
<a name="l00106"></a>00106 <span class="stringliteral">        my @xvals = @$xref;</span>
<a name="l00107"></a>00107 <span class="stringliteral">        my @qvals = @$qref;</span>
<a name="l00108"></a>00108 <span class="stringliteral">        my $y = pop(@qvals);</span>
<a name="l00109"></a>00109 <span class="stringliteral">                pop(@xvals);</span>
<a name="l00110"></a>00110 <span class="stringliteral">        while (@qvals) {</span>
<a name="l00111"></a>00111 <span class="stringliteral">            $y = $y * ($x - pop(@xvals) )  + pop(@qvals);</span>
<a name="l00112"></a>00112 <span class="stringliteral">        }</span>
<a name="l00113"></a>00113 <span class="stringliteral">        $y;</span>
<a name="l00114"></a>00114 <span class="stringliteral">     };</span>
<a name="l00115"></a>00115 <span class="stringliteral">     $fn;</span>
<a name="l00116"></a>00116 <span class="stringliteral">}</span>
<a name="l00117"></a>00117 <span class="stringliteral"></span>
<a name="l00118"></a>00118 <span class="stringliteral"></span>
<a name="l00119"></a>00119 <span class="stringliteral">=head3 Hermite polynomials</span>
<a name="l00120"></a>00120 <span class="stringliteral"></span>
<a name="l00121"></a>00121 <span class="stringliteral"></span>
<a name="l00122"></a>00122 <span class="stringliteral">=pod</span>
<a name="l00123"></a>00123 <span class="stringliteral"></span>
<a name="l00124"></a>00124 <span class="stringliteral">    Usage:  $poly = hermit([x0,x1...],[y0,y1...],[yp0,yp1,...]);</span>
<a name="l00125"></a>00125 <span class="stringliteral">        Produces a reference to polynomial function</span>
<a name="l00126"></a>00126 <span class="stringliteral">        with the specified values and first derivatives</span>
<a name="l00127"></a>00127 <span class="stringliteral">        at (x0,x1,...).</span>
<a name="l00128"></a>00128 <span class="stringliteral">        &amp;$poly(34) gives a number</span>
<a name="l00129"></a>00129 <span class="stringliteral"></span>
<a name="l00130"></a>00130 <span class="stringliteral">Generates a subroutine which evaluates a polynomial passing through the specified points</span>
<a name="l00131"></a>00131 <span class="stringliteral">with the specified derivatives: (x0,y0,yp0) ...</span>
<a name="l00132"></a>00132 <span class="stringliteral">The polynomial will be of high degree and may wobble unexpectedly.  Use the Hermite splines</span>
<a name="l00133"></a>00133 <span class="stringliteral">described below and in Hermite.pm for  most graphing purposes.</span>
<a name="l00134"></a>00134 <span class="stringliteral"></span>
<a name="l00135"></a>00135 <span class="stringliteral">=cut</span>
<a name="l00136"></a>00136 <span class="stringliteral"></span>
<a name="l00137"></a>00137 <span class="stringliteral"></span>
<a name="l00138"></a>00138 <span class="stringliteral">sub hermite {</span>
<a name="l00139"></a>00139 <span class="stringliteral">    my($x_ref,$y_ref,$yp_ref) = @_;</span>
<a name="l00140"></a>00140 <span class="stringliteral">    my (@zvals,@qvals);</span>
<a name="l00141"></a>00141 <span class="stringliteral">    my $n = $#{$x_ref};</span>
<a name="l00142"></a>00142 <span class="stringliteral">    my $i =0;</span>
<a name="l00143"></a>00143 <span class="stringliteral">    foreach $i (0..$n ) {</span>
<a name="l00144"></a>00144 <span class="stringliteral">        $zvals[2*$i] = $$x_ref[$i];</span>
<a name="l00145"></a>00145 <span class="stringliteral">        $zvals[2*$i+1] = $$x_ref[$i];</span>
<a name="l00146"></a>00146 <span class="stringliteral">        $qvals[2*$i][0] = $$y_ref[$i];</span>
<a name="l00147"></a>00147 <span class="stringliteral">        $qvals[2*$i+1][0] = $$y_ref[$i];</span>
<a name="l00148"></a>00148 <span class="stringliteral">        $qvals[2*$i+1][1] = $$yp_ref[$i];</span>
<a name="l00149"></a>00149 <span class="stringliteral">        $qvals[2*$i][1]  = ( $qvals[2*$i][0] - $qvals[2*$i-1][0] )</span>
<a name="l00150"></a>00150 <span class="stringliteral">                          / ( $zvals[2*$i]- $zvals[2*$i-1] ) unless $i ==0;</span>
<a name="l00151"></a>00151 <span class="stringliteral"></span>
<a name="l00152"></a>00152 <span class="stringliteral">    }</span>
<a name="l00153"></a>00153 <span class="stringliteral">    my $j;</span>
<a name="l00154"></a>00154 <span class="stringliteral">    foreach $i ( 2..(2*$n+1) )  {</span>
<a name="l00155"></a>00155 <span class="stringliteral">        foreach $j (2 .. $i) {</span>
<a name="l00156"></a>00156 <span class="stringliteral">            $qvals[$i][$j] = ($qvals[$i][$j-1] - $qvals[$i-1][$j-1]) /</span>
<a name="l00157"></a>00157 <span class="stringliteral">                              ($zvals[$i] - $zvals[$i-$j]);</span>
<a name="l00158"></a>00158 <span class="stringliteral">        }</span>
<a name="l00159"></a>00159 <span class="stringliteral">    }</span>
<a name="l00160"></a>00160 <span class="stringliteral">    my @output;</span>
<a name="l00161"></a>00161 <span class="stringliteral">    foreach $i (0..2*$n+1) {</span>
<a name="l00162"></a>00162 <span class="stringliteral">        push(@output,$qvals[$i][$i]);</span>
<a name="l00163"></a>00163 <span class="stringliteral">    }</span>
<a name="l00164"></a>00164 <span class="stringliteral">    horner(\@zvals,\@output);</span>
<a name="l00165"></a>00165 <span class="stringliteral">}</span>
<a name="l00166"></a>00166 <span class="stringliteral"></span>
<a name="l00167"></a>00167 <span class="stringliteral"></span>
<a name="l00168"></a>00168 <span class="stringliteral">=head3 Hermite splines</span>
<a name="l00169"></a>00169 <span class="stringliteral"></span>
<a name="l00170"></a>00170 <span class="stringliteral"></span>
<a name="l00171"></a>00171 <span class="stringliteral">    Usage:  $spline = hermit_spline([x0,x1...],[y0,y1...],[yp0,yp1,...]);</span>
<a name="l00172"></a>00172 <span class="stringliteral">        Produces a reference to a piecewise cubic hermit spline</span>
<a name="l00173"></a>00173 <span class="stringliteral">        with the specified values and first derivatives</span>
<a name="l00174"></a>00174 <span class="stringliteral">        at (x0,x1,...).</span>
<a name="l00175"></a>00175 <span class="stringliteral"></span>
<a name="l00176"></a>00176 <span class="stringliteral">        &amp;$spline(45) evaluates to a number.</span>
<a name="l00177"></a>00177 <span class="stringliteral"></span>
<a name="l00178"></a>00178 <span class="stringliteral">Generates a subroutine which evaluates a piecewise cubic polynomial</span>
<a name="l00179"></a>00179 <span class="stringliteral">passing through the specified points</span>
<a name="l00180"></a>00180 <span class="stringliteral">with the specified derivatives: (x0,y0,yp0) ...</span>
<a name="l00181"></a>00181 <span class="stringliteral"></span>
<a name="l00182"></a>00182 <span class="stringliteral">An object oriented version of this is defined in Hermite.pm</span>
<a name="l00183"></a>00183 <span class="stringliteral"></span>
<a name="l00184"></a>00184 <span class="stringliteral">=cut</span>
<a name="l00185"></a>00185 <span class="stringliteral"></span>
<a name="l00186"></a>00186 <span class="stringliteral"></span>
<a name="l00187"></a>00187 <span class="stringliteral">sub hermite_spline {</span>
<a name="l00188"></a>00188 <span class="stringliteral">    my ($xref, $yref, $ypref) = @_;</span>
<a name="l00189"></a>00189 <span class="stringliteral">    my @xvals  = @$xref;</span>
<a name="l00190"></a>00190 <span class="stringliteral">    my @yvals  = @$yref;</span>
<a name="l00191"></a>00191 <span class="stringliteral">    my @ypvals = @$ypref;</span>
<a name="l00192"></a>00192 <span class="stringliteral">    my $x0 = shift @xvals;</span>
<a name="l00193"></a>00193 <span class="stringliteral">    my $y0 = shift @yvals;</span>
<a name="l00194"></a>00194 <span class="stringliteral">    my $yp0 = shift @ypvals;</span>
<a name="l00195"></a>00195 <span class="stringliteral">    my ($x1,$y1,$yp1);</span>
<a name="l00196"></a>00196 <span class="stringliteral">    my @polys;  #calculate a hermite polynomial evaluator for each region</span>
<a name="l00197"></a>00197 <span class="stringliteral">    while (@xvals) {</span>
<a name="l00198"></a>00198 <span class="stringliteral">        $x1 = shift @xvals;</span>
<a name="l00199"></a>00199 <span class="stringliteral">        $y1 = shift @yvals;</span>
<a name="l00200"></a>00200 <span class="stringliteral">        $yp1 = shift @ypvals;</span>
<a name="l00201"></a>00201 <span class="stringliteral">        push @polys, hermite([$x0,$x1],[$y0,$y1],[$yp0,$yp1]);</span>
<a name="l00202"></a>00202 <span class="stringliteral">        $x0  = $x1;</span>
<a name="l00203"></a>00203 <span class="stringliteral">        $y0  = $y1;</span>
<a name="l00204"></a>00204 <span class="stringliteral">        $yp0 = $yp1;</span>
<a name="l00205"></a>00205 <span class="stringliteral">    }</span>
<a name="l00206"></a>00206 <span class="stringliteral"></span>
<a name="l00207"></a>00207 <span class="stringliteral"></span>
<a name="l00208"></a>00208 <span class="stringliteral">    my $hermite_spline_sub = sub {</span>
<a name="l00209"></a>00209 <span class="stringliteral">        my $x = shift;</span>
<a name="l00210"></a>00210 <span class="stringliteral">        my $y;</span>
<a name="l00211"></a>00211 <span class="stringliteral">        my $fun;</span>
<a name="l00212"></a>00212 <span class="stringliteral">        my @xvals = @$xref;</span>
<a name="l00213"></a>00213 <span class="stringliteral">        my @fns = @polys;</span>
<a name="l00214"></a>00214 <span class="stringliteral">        return $y=&amp;{$fns[0]} ($x) if $x == $xvals[0]; #handle left most endpoint</span>
<a name="l00215"></a>00215 <span class="stringliteral"></span>
<a name="l00216"></a>00216 <span class="stringliteral">        while (@xvals &amp;&amp; $x &gt; $xvals[0]) {  # find the function for this range of x</span>
<a name="l00217"></a>00217 <span class="stringliteral">            shift(@xvals);</span>
<a name="l00218"></a>00218 <span class="stringliteral">            $fun = shift(@fns);</span>
<a name="l00219"></a>00219 <span class="stringliteral">        }</span>
<a name="l00220"></a>00220 <span class="stringliteral"></span>
<a name="l00221"></a>00221 <span class="stringliteral">        # now that we have the left hand of the input</span>
<a name="l00222"></a>00222 <span class="stringliteral">        #check first that x isn&#39;</span>t out of range to the left or right
<a name="l00223"></a>00223         <span class="keywordflow">if</span> (@xvals  &amp;&amp; defined($fun) )  {
<a name="l00224"></a>00224             $y =&amp;$fun($x);
<a name="l00225"></a>00225         }
<a name="l00226"></a>00226         $y;
<a name="l00227"></a>00227     };
<a name="l00228"></a>00228     $hermite_spline_sub;
<a name="l00229"></a>00229 }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 =head3 Cubic spline approximation
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 
<a name="l00235"></a>00235     Usage:
<a name="l00236"></a>00236              $fun_ref = cubic_spline(~~@x_values, ~~@y_values);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 Where the x and y value arrays come from the function to be approximated.
<a name="l00239"></a>00239 The function reference will take a single value x and produce value y.
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         $y = &amp;$fun_ref($x);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 You can also generate javaScript which defines a cubic spline:
<a name="l00244"></a>00244 
<a name="l00245"></a>00245             $function_string = javaScript_cubic_spline(~~@_x_values, ~~@y_values,
<a name="l00246"></a>00246                       name =&gt;  <span class="stringliteral">&#39;myfunction1&#39;</span>,
<a name="l00247"></a>00247                       llimit =&gt; -3,
<a name="l00248"></a>00248                       rlimit =&gt; 3,
<a name="l00249"></a>00249                       );
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 The <span class="keywordtype">string</span> contains
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     &lt;SCRIPT LANGUAGE=<span class="stringliteral">&quot;JavaScript&quot;</span>&gt;
<a name="l00254"></a>00254     &lt;!-- Begin
<a name="l00255"></a>00255     function myfunction1(x) {
<a name="l00256"></a>00256     ...etc...
<a name="l00257"></a>00257     }
<a name="l00258"></a>00258     &lt;/SCRIPT&gt;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 and can be placed in the header of the HTML output <span class="keyword">using</span>
<a name="l00261"></a>00261 
<a name="l00262"></a>00262     HEADER_TEXT($function_string);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 =cut
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 sub cubic_spline {
<a name="l00267"></a>00267     my($t_ref, $y_ref) = @_;
<a name="l00268"></a>00268     my @spline_coeff = create_cubic_spline($t_ref, $y_ref);
<a name="l00269"></a>00269     sub {
<a name="l00270"></a>00270         my $x = shift;
<a name="l00271"></a>00271         eval_cubic_spline($x,@spline_coeff);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 sub eval_cubic_spline {
<a name="l00275"></a>00275     my ($x, $t_ref,$a_ref,$b_ref,$c_ref,$d_ref ) = @_;
<a name="l00276"></a>00276 <span class="preprocessor">#   The knot points given by $t_ref should be in order.</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span>    my $i=0;
<a name="l00278"></a>00278     my $out =0;
<a name="l00279"></a>00279     <span class="keywordflow">while</span> (defined($t_ref-&gt;[$i+1] ) &amp;&amp; $x  &gt;  $t_ref-&gt;[$i+1] ) {
<a name="l00280"></a>00280 
<a name="l00281"></a>00281         $i++;
<a name="l00282"></a>00282     }
<a name="l00283"></a>00283     unless (defined($t_ref-&gt;[$i]) &amp;&amp; ( $t_ref-&gt;[$i] &lt;= $x ) &amp;&amp; ($x &lt;= $t_ref-&gt;[$i+1] ) ) {
<a name="l00284"></a>00284         $out = undef;
<a name="l00285"></a>00285 <span class="preprocessor">        # input value is not in the range defined by the function.</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
<a name="l00287"></a>00287         $out = ( $t_ref-&gt;[$i+1]   - $x )* ( ($d_ref-&gt;[$i]) +($a_ref-&gt;[$i])*( $t_ref-&gt;[$i+1] - $x )**2 )
<a name="l00288"></a>00288                +
<a name="l00289"></a>00289                ( $x  -  $t_ref-&gt;[$i] ) * ( ($b_ref-&gt;[$i])*( $x  -  $t_ref-&gt;[$i] )**2  + ($c_ref-&gt;[$i]) )
<a name="l00290"></a>00290 
<a name="l00291"></a>00291     }
<a name="l00292"></a>00292     $out;
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="preprocessor">##########################################################################</span>
<a name="l00296"></a>00296 <span class="preprocessor"></span><span class="preprocessor"># Cubic spline algorithm adapted from p319 of Kincaid and Cheney&#39;s Numerical Analysis</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span><span class="preprocessor">##########################################################################</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>
<a name="l00299"></a>00299 sub create_cubic_spline {
<a name="l00300"></a>00300     my($t_ref, $y_ref) = @_;
<a name="l00301"></a>00301 <span class="preprocessor">#   The knot points are given by $t_ref (in order) and the function values by $y_ref</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span>    my $num =$#{$t_ref};  # number of knots
<a name="l00303"></a>00303     my $i;
<a name="l00304"></a>00304     my (@h,@b,@u,@v,@z);
<a name="l00305"></a>00305     <span class="keywordflow">foreach</span> $i (0..$num-1) {
<a name="l00306"></a>00306         $h[$i] = $t_ref-&gt;[$i+1] - $t_ref-&gt;[$i];
<a name="l00307"></a>00307         $b[$i] = 6*( $y_ref-&gt;[$i+1] - $y_ref-&gt;[$i] )/$h[$i];
<a name="l00308"></a>00308     }
<a name="l00309"></a>00309     $u[1] = 2*($h[0] +$h[1] );
<a name="l00310"></a>00310     $v[1] = $b[1] - $b[0];
<a name="l00311"></a>00311     <span class="keywordflow">foreach</span> $i (2..$num-1)    {
<a name="l00312"></a>00312         $u[$i] = 2*( $h[$i] + $h[$i-1] ) - ($h[$i-1])**2/$u[$i-1];
<a name="l00313"></a>00313         $v[$i] = $b[$i] - $b[$i-1] - $h[$i-1]*$v[$i-1]/$u[$i-1]
<a name="l00314"></a>00314     }
<a name="l00315"></a>00315     $z[$num] = 0;
<a name="l00316"></a>00316     <span class="keywordflow">for</span> ($i = $num-1; $i&gt;0; $i--)  {
<a name="l00317"></a>00317         $z[$i] = ( $v[$i] - $h[$i]*$z[$i+1] )/$u[$i];
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319     $z[0] = 0;
<a name="l00320"></a>00320     my ($a_ref, $b_ref, $c_ref, $d_ref);
<a name="l00321"></a>00321     <span class="keywordflow">foreach</span> $i (0..$num-1) {
<a name="l00322"></a>00322         $a_ref-&gt;[$i] = $z[$i]/(6*$h[$i]);
<a name="l00323"></a>00323         $b_ref-&gt;[$i] = $z[$i+1]/(6*$h[$i]);
<a name="l00324"></a>00324         $c_ref-&gt;[$i] = ( ($y_ref-&gt;[$i+1])/$h[$i] - $z[$i+1]*$h[$i]/6 );
<a name="l00325"></a>00325         $d_ref-&gt;[$i] = ( ($y_ref-&gt;[$i])/$h[$i] - $z[$i]*$h[$i]/6  );
<a name="l00326"></a>00326     }
<a name="l00327"></a>00327     ($t_ref, $a_ref, $b_ref, $c_ref, $d_ref);
<a name="l00328"></a>00328 }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 sub javaScript_cubic_spline {
<a name="l00332"></a>00332     my $x_ref = shift;
<a name="l00333"></a>00333     my $y_ref = shift;
<a name="l00334"></a>00334     my %options = @_;
<a name="l00335"></a>00335     assign_option_aliases(\%options,
<a name="l00336"></a>00336 
<a name="l00337"></a>00337     );
<a name="l00338"></a>00338     set_default_options(\%options,
<a name="l00339"></a>00339                         name            =&gt;  <span class="stringliteral">&#39;func&#39;</span>,
<a name="l00340"></a>00340                         llimit          =&gt;  $x_ref-&gt;[0],
<a name="l00341"></a>00341                         rlimit          =&gt;  $x_ref-&gt;[$#$x_ref],
<a name="l00342"></a>00342     );
<a name="l00343"></a>00343 
<a name="l00344"></a>00344     my ($t_ref, $a_ref, $b_ref, $c_ref, $d_ref) = create_cubic_spline ($x_ref, $y_ref);
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 my $str_t_array = <span class="stringliteral">&quot;t = new Array(&quot;</span> . join(<span class="stringliteral">&quot;,&quot;</span>,@$t_ref) . <span class="stringliteral">&quot;);&quot;</span>;
<a name="l00348"></a>00348 my $str_a_array = <span class="stringliteral">&quot;a = new Array(&quot;</span> . join(<span class="stringliteral">&quot;,&quot;</span>,@$a_ref) . <span class="stringliteral">&quot;);&quot;</span>;
<a name="l00349"></a>00349 my $str_b_array = <span class="stringliteral">&quot;b = new Array(&quot;</span> . join(<span class="stringliteral">&quot;,&quot;</span>,@$b_ref) . <span class="stringliteral">&quot;);&quot;</span>;
<a name="l00350"></a>00350 my $str_c_array = <span class="stringliteral">&quot;c = new Array(&quot;</span> . join(<span class="stringliteral">&quot;,&quot;</span>,@$c_ref) . <span class="stringliteral">&quot;);&quot;</span>;
<a name="l00351"></a>00351 my $str_d_array = <span class="stringliteral">&quot;d = new Array(&quot;</span> . join(<span class="stringliteral">&quot;,&quot;</span>,@$d_ref) . <span class="stringliteral">&quot;);&quot;</span>;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 my $output_str = &lt;&lt;END_OF_JAVA_TEXT;
<a name="l00354"></a>00354 &lt;SCRIPT LANGUAGE=<span class="stringliteral">&quot;JavaScript&quot;</span>&gt;
<a name="l00355"></a>00355 &lt;!-- Begin
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 function $options{name}(x) {
<a name="l00360"></a>00360     $str_t_array
<a name="l00361"></a>00361     $str_a_array
<a name="l00362"></a>00362     $str_b_array
<a name="l00363"></a>00363     $str_c_array
<a name="l00364"></a>00364     $str_d_array
<a name="l00365"></a>00365 
<a name="l00366"></a>00366     <span class="comment">// Evaluate a cubic spline defined by the vectors above</span>
<a name="l00367"></a>00367     i = 0;
<a name="l00368"></a>00368     <span class="keywordflow">while</span> (x &gt; t[i+1] ) {
<a name="l00369"></a>00369         i++
<a name="l00370"></a>00370     }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372     <span class="keywordflow">if</span> ( t[i] &lt;= x &amp;&amp; x &lt;= t[i+1]  &amp;&amp; $options{llimit} &lt;= x &amp;&amp; x &lt;= $options{rlimit} ) {
<a name="l00373"></a>00373         <span class="keywordflow">return</span> (   ( t[i+1] - x )*( d[i] +a[i]*( t[i+1] - x )*( t[i+1] - x ) )
<a name="l00374"></a>00374                  + ( x -   t[i] )*( b[i]*( x - t[i])*( x - t[i] ) +c[i] )
<a name="l00375"></a>00375                );
<a name="l00376"></a>00376 
<a name="l00377"></a>00377     } <span class="keywordflow">else</span> {
<a name="l00378"></a>00378         <span class="keywordflow">return</span>( <span class="stringliteral">&quot;undefined&quot;</span> ) ;
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 <span class="comment">// End</span>
<a name="l00383"></a>00383  --&gt;
<a name="l00384"></a>00384 &lt;/SCRIPT&gt;
<a name="l00385"></a>00385 &lt;NOSCRIPT&gt;
<a name="l00386"></a>00386 This problem requires a browser capable of processing javaScript
<a name="l00387"></a>00387 &lt;/NOSCRIPT&gt;
<a name="l00388"></a>00388 END_OF_JAVA_TEXT
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 $output_str;
<a name="l00391"></a>00391 }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 =head2 Numerical Integration methods
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 =head3 Integration by Left Hand Sum
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 =pod
<a name="l00399"></a>00399 
<a name="l00400"></a>00400     Usage:  lefthandsum(function_reference, start, end, steps=&gt;30 );
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 Implements the Left Hand sum <span class="keyword">using</span> 30 intervals between <span class="stringliteral">&#39;start&#39;</span> and <span class="stringliteral">&#39;end&#39;</span>.
<a name="l00403"></a>00403 The first three arguments are required.  The <span class="keyword">final</span> argument (number of steps) is optional and defaults to 30.
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 =cut
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 sub lefthandsum {
<a name="l00408"></a>00408     my $fn_ref = shift;
<a name="l00409"></a>00409         my $x0 = shift;
<a name="l00410"></a>00410         my $x1 = shift;
<a name="l00411"></a>00411         my %options = @_;
<a name="l00412"></a>00412         assign_option_aliases(\%options,
<a name="l00413"></a>00413                               intervals     =&gt;  <span class="stringliteral">&#39;steps&#39;</span>,
<a name="l00414"></a>00414     );
<a name="l00415"></a>00415     set_default_options(\%options,
<a name="l00416"></a>00416                         steps           =&gt;  30,
<a name="l00417"></a>00417         );
<a name="l00418"></a>00418     my $steps = $options{steps};
<a name="l00419"></a>00419     my $delta = ($x1-$x0)/$steps;
<a name="l00420"></a>00420         my $i;
<a name="l00421"></a>00421     my $sum=0;
<a name="l00422"></a>00422     <span class="keywordflow">foreach</span> $i (0..($steps-1) ) {
<a name="l00423"></a>00423         $sum =$sum + &amp;$fn_ref( $x0 + ($i)*$delta );
<a name="l00424"></a>00424     }
<a name="l00425"></a>00425     $sum*$delta;
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 =head3 Integration by Right Hand Sum
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 =pod
<a name="l00431"></a>00431 
<a name="l00432"></a>00432     Usage:  righthandsum(function_reference, start, end, steps=&gt;30 );
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 Implements the right hand sum <span class="keyword">using</span> 30 intervals between <span class="stringliteral">&#39;start&#39;</span> and <span class="stringliteral">&#39;end&#39;</span>.
<a name="l00435"></a>00435 The first three arguments are required.  The <span class="keyword">final</span> argument (number of steps) is optional and defaults to 30.
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 =cut
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 sub righthandsum {
<a name="l00440"></a>00440     my $fn_ref = shift;
<a name="l00441"></a>00441         my $x0 = shift;
<a name="l00442"></a>00442         my $x1 = shift;
<a name="l00443"></a>00443         my %options = @_;
<a name="l00444"></a>00444         assign_option_aliases(\%options,
<a name="l00445"></a>00445                               intervals     =&gt;  <span class="stringliteral">&#39;steps&#39;</span>,
<a name="l00446"></a>00446     );
<a name="l00447"></a>00447     set_default_options(\%options,
<a name="l00448"></a>00448                         steps           =&gt;  30,
<a name="l00449"></a>00449         );
<a name="l00450"></a>00450     my $steps = $options{steps};
<a name="l00451"></a>00451     my $delta = ($x1-$x0)/$steps;
<a name="l00452"></a>00452         my $i;
<a name="l00453"></a>00453     my $sum=0;
<a name="l00454"></a>00454     <span class="keywordflow">foreach</span> $i (1..($steps) ) {
<a name="l00455"></a>00455         $sum =$sum + &amp;$fn_ref( $x0 + ($i)*$delta );
<a name="l00456"></a>00456     }
<a name="l00457"></a>00457     $sum*$delta;
<a name="l00458"></a>00458 }
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 
<a name="l00461"></a>00461 =head3 Integration by Midpoint rule
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 =pod
<a name="l00464"></a>00464 
<a name="l00465"></a>00465     Usage:  midpoint(function_reference, start, end, steps=&gt;30 );
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 Implements the Midpoint rule <span class="keyword">using</span> 30 intervals between <span class="stringliteral">&#39;start&#39;</span> and <span class="stringliteral">&#39;end&#39;</span>.
<a name="l00468"></a>00468 The first three arguments are required.  The <span class="keyword">final</span> argument (number of steps) is optional and defaults to 30.
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 =cut
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 sub midpoint {
<a name="l00473"></a>00473     my $fn_ref = shift;
<a name="l00474"></a>00474         my $x0 = shift;
<a name="l00475"></a>00475         my $x1 = shift;
<a name="l00476"></a>00476         my %options = @_;
<a name="l00477"></a>00477         assign_option_aliases(\%options,
<a name="l00478"></a>00478                               intervals     =&gt;  <span class="stringliteral">&#39;steps&#39;</span>,
<a name="l00479"></a>00479     );
<a name="l00480"></a>00480     set_default_options(\%options,
<a name="l00481"></a>00481                         steps           =&gt;  30,
<a name="l00482"></a>00482         );
<a name="l00483"></a>00483     my $steps = $options{steps};
<a name="l00484"></a>00484     my $delta = ($x1-$x0)/$steps;
<a name="l00485"></a>00485         my $i;
<a name="l00486"></a>00486     my $sum=0;
<a name="l00487"></a>00487     <span class="keywordflow">foreach</span> $i (0..($steps-1) ) {
<a name="l00488"></a>00488         $sum =$sum + &amp;$fn_ref( $x0 + ($i+1/2)*$delta );
<a name="l00489"></a>00489     }
<a name="l00490"></a>00490     $sum*$delta;
<a name="l00491"></a>00491 }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 =head3 Integration by Simpson<span class="stringliteral">&#39;s rule</span>
<a name="l00494"></a>00494 <span class="stringliteral"></span>
<a name="l00495"></a>00495 <span class="stringliteral">=pod</span>
<a name="l00496"></a>00496 <span class="stringliteral"></span>
<a name="l00497"></a>00497 <span class="stringliteral">    Usage:  simpson(function_reference, start, end, steps=&gt;30 );</span>
<a name="l00498"></a>00498 <span class="stringliteral"></span>
<a name="l00499"></a>00499 <span class="stringliteral">Implements Simpson&#39;</span>s rule <span class="keyword">using</span> 30 intervals between <span class="stringliteral">&#39;start&#39;</span> and <span class="stringliteral">&#39;end&#39;</span>.
<a name="l00500"></a>00500 The first three arguments are required.  The <span class="keyword">final</span> argument (number of steps) is optional and defaults to 30,
<a name="l00501"></a>00501 but must be even.
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 =cut
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 sub simpson {
<a name="l00507"></a>00507     my $fn_ref = shift;
<a name="l00508"></a>00508         my $x0 = shift;
<a name="l00509"></a>00509         my $x1 = shift;
<a name="l00510"></a>00510         my %options = @_;
<a name="l00511"></a>00511         assign_option_aliases(\%options,
<a name="l00512"></a>00512                               intervals     =&gt;  <span class="stringliteral">&#39;steps&#39;</span>,
<a name="l00513"></a>00513     );
<a name="l00514"></a>00514     set_default_options(\%options,
<a name="l00515"></a>00515                         steps           =&gt;  30,
<a name="l00516"></a>00516         );
<a name="l00517"></a>00517     my $steps = $options{steps};
<a name="l00518"></a>00518         unless( $steps % 2 == 0  ) {
<a name="l00519"></a>00519         die <span class="stringliteral">&quot;Error: Simpson&#39;s rule requires an even number of steps.&quot;</span>;
<a name="l00520"></a>00520     }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522     my $delta = ($x1-$x0)/$steps;
<a name="l00523"></a>00523         my $i;
<a name="l00524"></a>00524     my $sum=0;
<a name="l00525"></a>00525     <span class="keywordflow">for</span> ($i=1;$i&lt;$steps;$i=$i+2) { # look <span class="keyword">this</span> up - loop by two.
<a name="l00526"></a>00526         $sum =$sum + 4*&amp;$fn_ref( $x0 + $i*$delta );
<a name="l00527"></a>00527     }
<a name="l00528"></a>00528     <span class="keywordflow">for</span> ($i=2;$i&lt;$steps-1;$i=$i+2) { # ditto
<a name="l00529"></a>00529         $sum = $sum + 2*&amp;$fn_ref( $x0 + $i*$delta);
<a name="l00530"></a>00530     }
<a name="l00531"></a>00531     $sum = $sum + &amp;$fn_ref($x0) + &amp;$fn_ref($x1);
<a name="l00532"></a>00532     $sum*$delta/3;
<a name="l00533"></a>00533 }
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 
<a name="l00536"></a>00536 =head3 Integration by trapezoid rule
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 =pod
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     Usage:  trapezoid(function_reference, start, end, steps=&gt;30 );
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 Implements the trapezoid rule <span class="keyword">using</span> 30 intervals between <span class="stringliteral">&#39;start&#39;</span> and <span class="stringliteral">&#39;end&#39;</span>.
<a name="l00543"></a>00543 The first three arguments are required.  The <span class="keyword">final</span> argument (number of steps)
<a name="l00544"></a>00544 is optional and defaults to 30.
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 =cut
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 sub trapezoid {
<a name="l00550"></a>00550     my $fn_ref = shift;
<a name="l00551"></a>00551     my $x0 = shift;
<a name="l00552"></a>00552     my $x1 = shift;
<a name="l00553"></a>00553     my %options = @_;
<a name="l00554"></a>00554     assign_option_aliases(\%options,
<a name="l00555"></a>00555                            intervals    =&gt;  <span class="stringliteral">&#39;steps&#39;</span>,
<a name="l00556"></a>00556     );
<a name="l00557"></a>00557     set_default_options(\%options,
<a name="l00558"></a>00558                         steps           =&gt;  30,
<a name="l00559"></a>00559     );
<a name="l00560"></a>00560     my $steps = $options{steps};
<a name="l00561"></a>00561     my $delta =($x1-$x0)/$steps;
<a name="l00562"></a>00562         my $i;
<a name="l00563"></a>00563     my $sum=0;
<a name="l00564"></a>00564     <span class="keywordflow">foreach</span> $i (1..($steps-1) ) {
<a name="l00565"></a>00565         $sum =$sum + &amp;$fn_ref( $x0 + $i*$delta );
<a name="l00566"></a>00566     }
<a name="l00567"></a>00567     $sum = $sum + 0.5*( &amp;$fn_ref($x0) + &amp;$fn_ref($x1) );
<a name="l00568"></a>00568     $sum*$delta;
<a name="l00569"></a>00569 }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 =head3  Romberg method of integration
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 =pod
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         Usage:  romberg(function_reference, x0, x1, level);
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 Implements the Romberg integration routine through <span class="stringliteral">&#39;level&#39;</span> recursive steps.  Level defaults to 6.
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 =cut
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 sub romberg {
<a name="l00583"></a>00583     my $fn_ref = shift;
<a name="l00584"></a>00584     my $x0 = shift;
<a name="l00585"></a>00585     my $x1 = shift;
<a name="l00586"></a>00586     my %options = @_;
<a name="l00587"></a>00587     set_default_options(\%options,
<a name="l00588"></a>00588                         level           =&gt;  6,
<a name="l00589"></a>00589     );
<a name="l00590"></a>00590     my $level = $options{level};
<a name="l00591"></a>00591     romberg_iter($fn_ref, $x0,$x1, $level,$level);
<a name="l00592"></a>00592 }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594 sub romberg_iter {
<a name="l00595"></a>00595     my $fn_ref = shift;
<a name="l00596"></a>00596     my $x0 = shift;
<a name="l00597"></a>00597     my $x1 = shift;
<a name="l00598"></a>00598     my $j  = shift;
<a name="l00599"></a>00599     my $k  = shift;
<a name="l00600"></a>00600     my $out;
<a name="l00601"></a>00601     <span class="keywordflow">if</span> ($k == 1 ) {
<a name="l00602"></a>00602         $out = trapezoid($fn_ref, $x0,$x1,steps =&gt; 2**($j-1) );
<a name="l00603"></a>00603     } <span class="keywordflow">else</span> {
<a name="l00604"></a>00604 
<a name="l00605"></a>00605         $out = (  4**($k-1) * romberg_iter($fn_ref, $x0,$x1,$j,$k-1) -
<a name="l00606"></a>00606                 romberg_iter($fn_ref, $x0,$x1,$j-1,$k-1) ) / ( 4**($k-1) -1) ;
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608     $out;
<a name="l00609"></a>00609 }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611 =head3 Inverse Romberg
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 =pod
<a name="l00614"></a>00614 
<a name="l00615"></a>00615         Usage: inv_romberg(function_reference, a, value);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 Finds b such that the integral of the function from a to b is equal to value.
<a name="l00618"></a>00618 Assumes that the function is continuous and doesn<span class="stringliteral">&#39;t take on the zero value.</span>
<a name="l00619"></a>00619 <span class="stringliteral">Uses Newton&#39;</span>s method of approximating roots of equations, and Romberg to evaluate definite integrals.
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 =cut
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 sub inv_romberg {
<a name="l00624"></a>00624         my $fn_ref = shift;
<a name="l00625"></a>00625         my $a = shift;
<a name="l00626"></a>00626         my $value = shift;
<a name="l00627"></a>00627         my $b = $a;
<a name="l00628"></a>00628         my $delta = 1;
<a name="l00629"></a>00629         my $i=0;
<a name="l00630"></a>00630         my $funct;
<a name="l00631"></a>00631         my $deriv;
<a name="l00632"></a>00632         <span class="keywordflow">while</span> (abs($delta) &gt; 0.000001 &amp;&amp; $i &lt; 5000) {
<a name="l00633"></a>00633                 $funct = romberg($fn_ref,$a,$b)-$value;
<a name="l00634"></a>00634                 $deriv = &amp;$fn_ref ( $b );
<a name="l00635"></a>00635             <span class="keywordflow">if</span> ($deriv == 0) {
<a name="l00636"></a>00636             warn <span class="stringliteral">&#39;Values of the function are too close to 0.&#39;</span>;
<a name="l00637"></a>00637                         <span class="keywordflow">return</span>;
<a name="l00638"></a>00638                 }
<a name="l00639"></a>00639                 $delta = $funct/$deriv;
<a name="l00640"></a>00640                 $b = $b - $delta;
<a name="l00641"></a>00641                 $i++;
<a name="l00642"></a>00642         }
<a name="l00643"></a>00643         <span class="keywordflow">if</span> ($i == 5000) {
<a name="l00644"></a>00644                 warn <span class="stringliteral">&#39;Newtons method does not converge.&#39;</span>;
<a name="l00645"></a>00645                 <span class="keywordflow">return</span>;
<a name="l00646"></a>00646     }
<a name="l00647"></a>00647         $b;
<a name="l00648"></a>00648 }
<a name="l00649"></a>00649 
<a name="l00650"></a>00650 <span class="preprocessor">#########################################################</span>
<a name="l00651"></a>00651 <span class="preprocessor"></span>=pod
<a name="l00652"></a>00652 
<a name="l00653"></a>00653     rungeKutta4
<a name="l00654"></a>00654     
<a name="l00655"></a>00655     Finds integral curve of a vector field <span class="keyword">using</span> the 4th order Runge Kutta method.
<a name="l00656"></a>00656     
<a name="l00657"></a>00657     Useage:  rungeKutta4( &amp;vectorField(t,x),%options);
<a name="l00658"></a>00658     
<a name="l00659"></a>00659     Returns:  \@array of points [t,y})  
<a name="l00660"></a>00660     
<a name="l00661"></a>00661     Default %options:
<a name="l00662"></a>00662                 <span class="stringliteral">&#39;initial_t&#39;</span>                 =&gt;  1,
<a name="l00663"></a>00663                 <span class="stringliteral">&#39;initial_y&#39;</span>                 =&gt;  1,
<a name="l00664"></a>00664                 <span class="stringliteral">&#39;dt&#39;</span>                        =&gt;  .01,
<a name="l00665"></a>00665                 <span class="stringliteral">&#39;num_of_points&#39;</span>             =&gt;  10,     #number of reported points
<a name="l00666"></a>00666                 <span class="stringliteral">&#39;interior_points&#39;</span>           =&gt;  5,      # number of <span class="stringliteral">&#39;interior&#39;</span> steps between reported points
<a name="l00667"></a>00667                 <span class="stringliteral">&#39;debug&#39;</span>         
<a name="l00668"></a>00668     
<a name="l00669"></a>00669 =cut
<a name="l00670"></a>00670 
<a name="l00671"></a>00671 sub rungeKutta4 { 
<a name="l00672"></a>00672     my $rf_fun = shift;
<a name="l00673"></a>00673     my %options = @_;
<a name="l00674"></a>00674     set_default_options(    \%options,
<a name="l00675"></a>00675                 <span class="stringliteral">&#39;initial_t&#39;</span>                 =&gt;  1,
<a name="l00676"></a>00676                 <span class="stringliteral">&#39;initial_y&#39;</span>                 =&gt;  1,
<a name="l00677"></a>00677                 <span class="stringliteral">&#39;dt&#39;</span>                        =&gt;  .01,
<a name="l00678"></a>00678                 <span class="stringliteral">&#39;num_of_points&#39;</span>             =&gt;  10,     #number of reported points
<a name="l00679"></a>00679                 <span class="stringliteral">&#39;interior_points&#39;</span>           =&gt;  5,      # number of <span class="stringliteral">&#39;interior&#39;</span> steps between reported points
<a name="l00680"></a>00680                 <span class="stringliteral">&#39;debug&#39;</span>                     =&gt;  1,      # remind programmers to always pass the debug parameter
<a name="l00681"></a>00681                 );
<a name="l00682"></a>00682     my $t = $options{initial_t};
<a name="l00683"></a>00683     my $y = $options{initial_y};
<a name="l00684"></a>00684     
<a name="l00685"></a>00685     my $num = $options{<span class="stringliteral">&#39;num_of_points&#39;</span>};  # number of points
<a name="l00686"></a>00686     my $num2 = $options{<span class="stringliteral">&#39;interior_points&#39;</span>};  # number of steps between points.
<a name="l00687"></a>00687     my $dt   = $options{<span class="stringliteral">&#39;dt&#39;</span>}; 
<a name="l00688"></a>00688     my $errors = undef;
<a name="l00689"></a>00689     my $rf_rhs = sub {  my @in = @_; 
<a name="l00690"></a>00690                 my ( $out, $err) = &amp;$rf_fun(@in);
<a name="l00691"></a>00691                 $errors .= <span class="stringliteral">&quot; $err at ( &quot;</span>.join(<span class="stringliteral">&quot; , &quot;</span>, @in) . <span class="stringliteral">&quot; )&lt;br&gt;\n&quot;</span> <span class="keywordflow">if</span> defined($err);
<a name="l00692"></a>00692                 $out = <span class="stringliteral">&#39;NaN&#39;</span> <span class="keywordflow">if</span> defined($err) and not is_a_number($out);
<a name="l00693"></a>00693                 $out;
<a name="l00694"></a>00694                 };
<a name="l00695"></a>00695     
<a name="l00696"></a>00696     my @output = ([$t, $y]);
<a name="l00697"></a>00697     my ($i, $j, $K1,$K2,$K3,$K4);
<a name="l00698"></a>00698     
<a name="l00699"></a>00699     for ($j=0; $j&lt;$num; $j++) {
<a name="l00700"></a>00700         <span class="keywordflow">for</span> ($i=0; $i&lt;$num2; $i++) {    
<a name="l00701"></a>00701         $K1 = $dt*&amp;$rf_rhs($t, $y);
<a name="l00702"></a>00702         $K2 = $dt*&amp;$rf_rhs($t+$dt/2,$y+$K1/2);
<a name="l00703"></a>00703         $K3 = $dt*&amp;$rf_rhs($t+$dt/2, $y+$K2/2);
<a name="l00704"></a>00704         $K4 = $dt*&amp;$rf_rhs($t+$dt, $y+$K3);
<a name="l00705"></a>00705         $y = $y + ($K1 + 2*$K2 + 2*$K3 + $K4)/6;
<a name="l00706"></a>00706         $t = $t + $dt;
<a name="l00707"></a>00707         }
<a name="l00708"></a>00708         push(@output, [$t, $y]);
<a name="l00709"></a>00709     }
<a name="l00710"></a>00710     <span class="keywordflow">if</span> (defined $errors) {
<a name="l00711"></a>00711         <span class="keywordflow">return</span> $errors;
<a name="l00712"></a>00712     } <span class="keywordflow">else</span> {
<a name="l00713"></a>00713         <span class="keywordflow">return</span> \@output;
<a name="l00714"></a>00714     }
<a name="l00715"></a>00715 }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717 
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 1;
<a name="l00720"></a>00720 
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Jun 8 22:54:56 2012 for PG by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
