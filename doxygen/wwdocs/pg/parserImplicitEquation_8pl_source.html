<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PG: parserImplicitEquation.pl Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>parserImplicitEquation.pl</h1><a href="parserImplicitEquation_8pl.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">################################################################################</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor"># WeBWorK Online Homework Delivery System</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor"># Copyright © 2000-2007 The WeBWorK Project, http://openwebwork.sf.net/</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="preprocessor"># $CVSHeader: pg/macros/parserImplicitEquation.pl,v 1.14 2009/06/25 23:28:44 gage Exp $</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span><span class="preprocessor"># </span>
<a name="l00006"></a>00006 <span class="preprocessor"></span><span class="preprocessor"># This program is free software; you can redistribute it and/or modify it under</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span><span class="preprocessor"># the terms of either: (a) the GNU General Public License as published by the</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor"># Free Software Foundation; either version 2, or (at your option) any later</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor"># version, or (b) the &quot;Artistic License&quot; which comes with this package.</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="preprocessor"># </span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor"># This program is distributed in the hope that it will be useful, but WITHOUT</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span><span class="preprocessor"># ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span><span class="preprocessor"># FOR A PARTICULAR PURPOSE.  See either the GNU General Public License or the</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor"># Artistic License for more details.</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">################################################################################</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span>
<a name="l00017"></a>00017 =head1 NAME
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 parserImplicitEquation.pl - An answer checker <span class="keywordflow">for</span> implicit equations.
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 =head1 DESCRIPTION
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 This is a MathObject <span class="keyword">class </span>that <span class="keyword">implements</span> an answer checker for
<a name="l00024"></a>00024 implicitly defined equations.  The checker looks for the zeros of
<a name="l00025"></a>00025 the equation and tests that the student and professor equations
<a name="l00026"></a>00026 both have the same solutions.
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 This type of check is very subtle, and there are important issues
<a name="l00029"></a>00029 that you may have to take into account.  The solutions to the
<a name="l00030"></a>00030 equations are found numerically, and so they will not be exact;
<a name="l00031"></a>00031 that means that there are tolerances that may need to be adjusted
<a name="l00032"></a>00032 for your particular equation.  Also, it is always possible for the
<a name="l00033"></a>00033 student to represent the function in a form that will exceed those
<a name="l00034"></a>00034 tolerances, and so be marked as incorrect.  The answer checker
<a name="l00035"></a>00035 attempts to set the parameters based on the values of the <a class="code" href="PGstringevaluators_8pl.html#a432234fc3d5710ff4fdc5eacd9a0eae2">functions</a>
<a name="l00036"></a>00036 involved, but this may not work perfectly.
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 The method used to locate the solutions of A=B is by finding zeros
<a name="l00039"></a>00039 of A-B, and it requires this function to take on both positive and
<a name="l00040"></a>00040 negative values (that is, it can only find transverse intersections
<a name="l00041"></a>00041 of the surface A-B=0 and the plane at height 0).  For example, even
<a name="l00042"></a>00042 though the solutions of (x^2+y^1-1)^2=0 form a circle, the
<a name="l00043"></a>00043 algorithm will fail to find any solutions for this equation.
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 In order to locate the zeros, you may need to change the limits so
<a name="l00046"></a>00046 that they include regions where the function is both positive and
<a name="l00047"></a>00047 negative (see below).  The algorithm will avoid discontinuities, so
<a name="l00048"></a>00048 you can specify things like x-y=1/(x+y) rather than x^2-y^2=1.
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 Because the solutions are found using a random search, it is
<a name="l00051"></a>00051 possible the randomly chosen starting points don&#39;t locate enough
<a name="l00052"></a>00052 zeros for the function, in which case the check will fail.  This
<a name="l00053"></a>00053 can happen for both the professor&#39;s function and the student&#39;s,
<a name="l00054"></a>00054 since zeros are found for both.  This means that a correct answer
<a name="l00055"></a>00055 can sometimes be marked incorrect depending on the random points
<a name="l00056"></a>00056 chosen initially.  These points also affect the values selected for
<a name="l00057"></a>00057 the tolerances used to determine when a function&#39;s value is zero,
<a name="l00058"></a>00058 and so can affect whether the student&#39;s function is marked as
<a name="l00059"></a>00059 correct or not.
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 If an equation has several components or branches, it is possible
<a name="l00062"></a>00062 that the random location of solutions will not find zeros on some
<a name="l00063"></a>00063 of the branches, and so might incorrectly mark as correct an
<a name="l00064"></a>00064 equation that only is zero on one of the components.  For example,
<a name="l00065"></a>00065 x^2-y^2=0 has solutions along the lines y=x and y=-x, so it is
<a name="l00066"></a>00066 possible that x-y=0 or x+y=0 will be marked as correct if the
<a name="l00067"></a>00067 random points are unluckily chosen.  One way to reduce this problem
<a name="l00068"></a>00068 is to increase the number of solutions that are required (by
<a name="l00069"></a>00069 setting the ImplicitPoints flag in the Context).  Another is to
<a name="l00070"></a>00070 specify the solutions yourself, so that you are sure there are
<a name="l00071"></a>00071 points on each component.
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 These problems should be rare, and the values for the various
<a name="l00074"></a>00074 parameters have been set in an attempt to minimize the possibility
<a name="l00075"></a>00075 of these errors, but they can occur, and you should be aware of
<a name="l00076"></a>00076 them, and their possible solutions.
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 Usage examples:
<a name="l00079"></a>00079 
<a name="l00080"></a>00080     Context(&quot;ImplicitEquation&quot;);
<a name="l00081"></a>00081     $f = <a class="code" href="classImplicitEquation.html">ImplicitEquation</a>(&quot;x^2 = cos(y)&quot;);
<a name="l00082"></a>00082     $f = <a class="code" href="classImplicitEquation.html">ImplicitEquation</a>(&quot;x^2 - 2y^2 = 5&quot;,limits=&gt;[[-3,3],[-2,2]]);
<a name="l00083"></a>00083     $f = <a class="code" href="classImplicitEquation.html">ImplicitEquation</a>(&quot;x=1/y&quot;,tolerance=&gt;.0001);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 Then use
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     <a class="code" href="PGstringevaluators_8pl.html#a33aa1133c9196fed55af79d192977ed3">ANS</a>($f-&gt;cmp);
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 to get the answer checker for $f.
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 There are a number of Context flags that control the answer checker.
<a name="l00092"></a>00092 These include:
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 =over
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 =item C&lt;S&lt;&lt; ImplicitPoints =&gt; 7 &gt;&gt;&gt;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 the number of solutions to test.
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 =item C&lt;S&lt;&lt; ImplicitTolerance =&gt; 1E-6 &gt;&gt;&gt;
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 relative tolerance value for when
<a name="l00103"></a>00103 the tested function is zero.
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 =item C&lt;S&lt;&lt; ImplicitAbsoluteMinTolerance =&gt; 1E-3 &gt;&gt;&gt;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 the minimum tolerance allowed.
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 =item C&lt;S&lt;&lt; ImplicitAbsoluteMaxTolerance =&gt; 1 &gt;&gt;&gt;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 the maximum tolerance allowed.
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 =item C&lt;S&lt;&lt; ImplicitPointTolerance =&gt; 1E-9 &gt;&gt;&gt;
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 relative tolerance for how close
<a name="l00116"></a>00116 the solution point must be to an
<a name="l00117"></a>00117 actual solution.
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 =item C&lt;S&lt;&lt; BisectionTolerance =&gt; .01 &gt;&gt;&gt;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 extra factor used for the tolerance
<a name="l00122"></a>00122 when finding the solutions.
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 =item C&lt;S&lt;&lt; BisectionCutoff =&gt; 40 &gt;&gt;&gt;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 maximum number of bisections to
<a name="l00127"></a>00127 perform when looking for a solution.
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 =back
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 You may set any of these using Context()-&gt;flags-&gt;set(...).
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 In addition to the Context flags, you can set some values within
<a name="l00134"></a>00134 the <a class="code" href="classImplicitEquation.html">ImplicitEquation</a> itself:
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 =over
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 =item C&lt;S&lt;&lt; tolerance &gt;&gt;&gt;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 the absolute tolerance for zeros of the function.
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 =item C&lt;S&lt;&lt; bisect_tolerance &gt;&gt;&gt;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 the tolerance used when searching for zeros.
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 =item C&lt;S&lt;&lt; point_tolerance &gt;&gt;&gt;
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 the absolute tolerance for how close to an
<a name="l00149"></a>00149 actual solution the located solution must be.
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 =item C&lt;S&lt;&lt; limits &gt;&gt;&gt;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 the domain to use for the function; see the
<a name="l00154"></a>00154 documentation for the Formula object.
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 =item C&lt;S&lt;&lt; solutions &gt;&gt;&gt;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 a reference to an array of references to arrays
<a name="l00159"></a>00159 that contain the coordinates of the points
<a name="l00160"></a>00160 that are the solutions of the equation.
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 =back
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 These can be set in the in the <a class="code" href="classImplicitEquation.html">ImplicitEquation</a>() call that creates
<a name="l00165"></a>00165 the object, as in the examples below:
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 For example:
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     $f = <a class="code" href="classImplicitEquation.html">ImplicitEquation</a>(&quot;x^2-y^2=0&quot;,
<a name="l00170"></a>00170         solutions =&gt; [[0,0],[1,1],[-1,1],[-1,-1],[1,-1]],
<a name="l00171"></a>00171         tolerance =&gt; .001
<a name="l00172"></a>00172     );
<a name="l00173"></a>00173 
<a name="l00174"></a>00174     $f = <a class="code" href="classImplicitEquation.html">ImplicitEquation</a>(&quot;xy=5&quot;,limits=&gt;[-3,3]);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 The limits value can be set globally within the Context, if you wish,
<a name="l00177"></a>00177 and the others can be controlled by the Context flags discussed
<a name="l00178"></a>00178 above.
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 =cut
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 loadMacros(&quot;MathObjects.pl&quot;);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 sub _parserImplicitEquation_init {<a class="code" href="classImplicitEquation.html#a97fa425fb4fe8cf2ef696d8c4e229fd9">ImplicitEquation::Init</a>()}; # don<span class="stringliteral">&#39;t reload this file</span>
<a name="l00185"></a>00185 <span class="stringliteral"></span>
<a name="l00186"></a>00186 <span class="stringliteral">#</span>
<a name="l00187"></a>00187 <span class="stringliteral">#  Create the ImplicitEquation package</span>
<a name="l00188"></a>00188 <span class="stringliteral">#</span>
<a name="l00189"></a>00189 <span class="stringliteral">package ImplicitEquation;</span>
<a name="l00190"></a>00190 <span class="stringliteral">our @ISA = qw(Value::Formula);</span>
<a name="l00191"></a>00191 <span class="stringliteral"></span>
<a name="l00192"></a>00192 <span class="stringliteral">sub Init {</span>
<a name="l00193"></a>00193 <span class="stringliteral">  my $context = $main::context{ImplicitEquation} = Parser::Context-&gt;getCopy(&quot;Numeric&quot;);</span>
<a name="l00194"></a>00194 <span class="stringliteral">  $context-&gt;{name} = &quot;ImplicitEquation&quot;;</span>
<a name="l00195"></a>00195 <span class="stringliteral">  $context-&gt;variables-&gt;are(x=&gt;&#39;</span>Real<span class="stringliteral">&#39;,y=&gt;&#39;</span>Real<span class="stringliteral">&#39;);</span>
<a name="l00196"></a>00196 <span class="stringliteral">  $context{precedence}{ImplicitEquation} = $context-&gt;{precedence}{special};</span>
<a name="l00197"></a>00197 <span class="stringliteral">  Parser::BOP::equality-&gt;Allow($context);</span>
<a name="l00198"></a>00198 <span class="stringliteral">  $context-&gt;flags-&gt;set(</span>
<a name="l00199"></a>00199 <span class="stringliteral">    ImplicitPoints =&gt; 10,</span>
<a name="l00200"></a>00200 <span class="stringliteral">    ImplicitTolerance =&gt; 1E-6,</span>
<a name="l00201"></a>00201 <span class="stringliteral">    ImplicitAbsoluteMinTolerance =&gt; 1E-3,</span>
<a name="l00202"></a>00202 <span class="stringliteral">    ImplicitAbsoluteMaxTolerance =&gt; 1,</span>
<a name="l00203"></a>00203 <span class="stringliteral">    ImplicitPointTolerance =&gt; 1E-9,</span>
<a name="l00204"></a>00204 <span class="stringliteral">    BisectionTolerance =&gt; .01,</span>
<a name="l00205"></a>00205 <span class="stringliteral">    BisectionCutoff =&gt; 40,</span>
<a name="l00206"></a>00206 <span class="stringliteral">  );</span>
<a name="l00207"></a>00207 <span class="stringliteral"></span>
<a name="l00208"></a>00208 <span class="stringliteral">  main::Context(&quot;ImplicitEquation&quot;);  ### FIXEME:  probably should require author to set this explicitly</span>
<a name="l00209"></a>00209 <span class="stringliteral"></span>
<a name="l00210"></a><a class="code" href="classImplicitEquation.html">00210</a> <span class="stringliteral">  main::PG_restricted_eval(&#39;</span>sub <a class="code" href="classImplicitEquation.html">ImplicitEquation</a> {<a class="code" href="classImplicitEquation.html">ImplicitEquation</a>-&gt;new(@_)}<span class="stringliteral">&#39;);</span>
<a name="l00211"></a>00211 <span class="stringliteral">}</span>
<a name="l00212"></a>00212 <span class="stringliteral"></span>
<a name="l00213"></a>00213 <span class="stringliteral">sub new {</span>
<a name="l00214"></a>00214 <span class="stringliteral">  my $self = shift; my $class = ref($self) || $self;</span>
<a name="l00215"></a>00215 <span class="stringliteral">  my $context = (Value::isContext($_[0]) ? shift : $self-&gt;context);</span>
<a name="l00216"></a>00216 <span class="stringliteral">  my $f = shift; return $f if ref($f) eq $class;</span>
<a name="l00217"></a>00217 <span class="stringliteral">  $f = $context-&gt;Package(&quot;Formula&quot;)-&gt;new($context,$f);</span>
<a name="l00218"></a>00218 <span class="stringliteral">  Value::Error(&quot;Your formula doesn&#39;</span>t look like an implicit equation<span class="stringliteral">&quot;)</span>
<a name="l00219"></a>00219 <span class="stringliteral">    unless $f-&gt;type eq &#39;Equality&#39;;</span>
<a name="l00220"></a>00220 <span class="stringliteral">  my $F = ($context-&gt;Package(&quot;</span>Formula<span class="stringliteral">&quot;)-&gt;new($context,$f-&gt;{tree}{lop}) -</span>
<a name="l00221"></a>00221 <span class="stringliteral">       $context-&gt;Package(&quot;</span>Formula<span class="stringliteral">&quot;)-&gt;new($context,$f-&gt;{tree}{rop}))-&gt;reduce;</span>
<a name="l00222"></a>00222 <span class="stringliteral">  $F = $context-&gt;Package(&quot;</span>Formula<span class="stringliteral">&quot;)-&gt;new($context,$F) unless Value::isFormula($F);</span>
<a name="l00223"></a>00223 <span class="stringliteral">  Value::Error(&quot;</span>Your equation must be real-valued<span class="stringliteral">&quot;) unless $F-&gt;isRealNumber;</span>
<a name="l00224"></a>00224 <span class="stringliteral">  Value::Error(&quot;</span>Your equation should not be constant<span class="stringliteral">&quot;) if $F-&gt;isConstant;</span>
<a name="l00225"></a>00225 <span class="stringliteral">  Value::Error(&quot;</span>Your equation can not contain adaptive parameters<span class="stringliteral">&quot;)</span>
<a name="l00226"></a>00226 <span class="stringliteral">    if ($F-&gt;usesOneOf($context-&gt;variables-&gt;parameters));</span>
<a name="l00227"></a>00227 <span class="stringliteral">  $F = bless $F, $class;</span>
<a name="l00228"></a>00228 <span class="stringliteral">  my %options = (@_);  # user can supply limits, tolerance, etc.</span>
<a name="l00229"></a>00229 <span class="stringliteral">  foreach my $id (keys %options) {$F-&gt;{$id} = $options{$id}}</span>
<a name="l00230"></a>00230 <span class="stringliteral">  $F-&gt;{F} = $f; $F-&gt;{isValue} = $F-&gt;{isFormula} = 1;</span>
<a name="l00231"></a>00231 <span class="stringliteral">  $F-&gt;createPoints unless $F-&gt;{solutions};</span>
<a name="l00232"></a>00232 <span class="stringliteral">  return $F;</span>
<a name="l00233"></a>00233 <span class="stringliteral">}</span>
<a name="l00234"></a>00234 <span class="stringliteral"></span>
<a name="l00235"></a>00235 <span class="stringliteral">#</span>
<a name="l00236"></a>00236 <span class="stringliteral">#  Override the comparison method.</span>
<a name="l00237"></a>00237 <span class="stringliteral">#</span>
<a name="l00238"></a>00238 <span class="stringliteral">#  Turn the right-hand equation into an ImplicitEquation.  This creates</span>
<a name="l00239"></a>00239 <span class="stringliteral">#  the test points (i.e., finds the solution points).  Then check</span>
<a name="l00240"></a>00240 <span class="stringliteral">#  the professor&#39;s function on the student&#39;s test points and the</span>
<a name="l00241"></a>00241 <span class="stringliteral">#  student&#39;s function on the professor&#39;s test points.</span>
<a name="l00242"></a>00242 <span class="stringliteral">#</span>
<a name="l00243"></a>00243 <span class="stringliteral"></span>
<a name="l00244"></a>00244 <span class="stringliteral">sub compare {</span>
<a name="l00245"></a>00245 <span class="stringliteral">  my ($l,$r) = @_; my $self = $l; my $tolerance;</span>
<a name="l00246"></a>00246 <span class="stringliteral">  my @params; @params = (limits=&gt;$l-&gt;{limits}) if $l-&gt;{limits};</span>
<a name="l00247"></a>00247 <span class="stringliteral">  $r = ImplicitEquation-&gt;new($r,@params);</span>
<a name="l00248"></a>00248 <span class="stringliteral">  Value::Error(&quot;</span>Functions from different contexts can<span class="stringliteral">&#39;t be compared&quot;)</span>
<a name="l00249"></a>00249 <span class="stringliteral">    unless $l-&gt;{context} == $r-&gt;{context};</span>
<a name="l00250"></a>00250 <span class="stringliteral"></span>
<a name="l00251"></a>00251 <span class="stringliteral">  #</span>
<a name="l00252"></a>00252 <span class="stringliteral">  #  They are not equal if couldn&#39;</span>t <span class="keyword">get</span> solutions <span class="keywordflow">for</span> one of them
<a name="l00253"></a>00253 <span class="preprocessor">  #</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 1 unless $l-&gt;{solutions} &amp;&amp; $r-&gt;{solutions};
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 <span class="preprocessor">  #</span>
<a name="l00257"></a>00257 <span class="preprocessor"></span><span class="preprocessor">  #  Test the right-hand function on the solutions of the left-hand one</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span><span class="preprocessor">  #  and vice-versa</span>
<a name="l00259"></a>00259 <span class="preprocessor"></span><span class="preprocessor">  #</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>  my $rzeros = $r-&gt;createPointValues($l-&gt;{solutions});
<a name="l00261"></a>00261   my $lzeros = $l-&gt;createPointValues($r-&gt;{solutions});
<a name="l00262"></a>00262   <span class="keywordflow">return</span> 1 unless $lzeros &amp;&amp; $rzeros;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="preprocessor">  #</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span><span class="preprocessor">  #  Check that the values are, in fact, zeros</span>
<a name="l00266"></a>00266 <span class="preprocessor"></span><span class="preprocessor">  #</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span>  $tolerance = $r-&gt;getFlag(<span class="stringliteral">&#39;tolerance&#39;</span>,1E-3);
<a name="l00268"></a>00268   <span class="keywordflow">foreach</span> my $v (@{$rzeros}) {<span class="keywordflow">return</span> 1 unless abs($v) &lt; $tolerance}
<a name="l00269"></a>00269   $tolerance = $l-&gt;getFlag(<span class="stringliteral">&#39;tolerance&#39;</span>,1E-3);
<a name="l00270"></a>00270   <span class="keywordflow">foreach</span> my $v (@{$lzeros}) {<span class="keywordflow">return</span> 1 unless abs($v) &lt; $tolerance}
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="keywordflow">return</span> 0; # equal
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="preprocessor">#</span>
<a name="l00276"></a>00276 <span class="preprocessor"></span><span class="preprocessor">#  Use the original equation for these (but not for perl(), since we</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span><span class="preprocessor">#  need that to use perlFunction).</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00279"></a>00279 <span class="preprocessor"></span>sub <span class="keywordtype">string</span> {shift-&gt;{F}-&gt;string}
<a name="l00280"></a>00280 sub TeX    {shift-&gt;{F}-&gt;TeX}
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 sub cmp_class {<span class="stringliteral">&#39;an Implicit Equation&#39;</span>}
<a name="l00283"></a>00283 sub showClass {shift-&gt;cmp_class}
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 <span class="preprocessor">#</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span><span class="preprocessor">#  Locate points that satisfy the equation</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span>sub createPoints {
<a name="l00289"></a>00289   my $self = shift;
<a name="l00290"></a>00290   my $num_points = int($self-&gt;getFlag(<span class="stringliteral">&#39;ImplicitPoints&#39;</span>,10));
<a name="l00291"></a>00291   $num_points = 1 <span class="keywordflow">if</span> $num_points &lt; 1;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="preprocessor">  #</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span><span class="preprocessor">  #  Get some positive and negative test points (try up to 5 times)</span>
<a name="l00295"></a>00295 <span class="preprocessor"></span><span class="preprocessor">  #</span>
<a name="l00296"></a>00296 <span class="preprocessor"></span>  my ($OK,$p,$n,$z,$f,@zero); my $k = 5;
<a name="l00297"></a>00297   <span class="keywordflow">while</span> (!$OK &amp;&amp; --$k) {($OK,$p,$n,$z,$f) = $self-&gt;getPositiveNegativeZero($num_points)}
<a name="l00298"></a>00298   <a class="code" href="classValue.html#a26f0e9926e446d67e29db24fd4300279">Value::Error</a>(<span class="stringliteral">&quot;Can&#39;t find any solutions to your equation&quot;</span>) unless $OK;
<a name="l00299"></a>00299   my ($P,@intervals) = $self-&gt;getIntervals($p,$n);
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   <span class="preprocessor">#</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span><span class="preprocessor">  #  Get relative tolerance values and make them absolute</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span><span class="preprocessor">  #</span>
<a name="l00304"></a>00304 <span class="preprocessor"></span>  my $minTolerance = $self-&gt;getFlag(<span class="stringliteral">&#39;ImplicitAbsoluteMinTolerance&#39;</span>);
<a name="l00305"></a>00305   my $maxTolerance = $self-&gt;getFlag(<span class="stringliteral">&#39;ImplicitAbsoluteMaxTolerance&#39;</span>);
<a name="l00306"></a>00306   my $tolerance = $f * $self-&gt;getFlag(<span class="stringliteral">&#39;ImplicitTolerance&#39;</span>);
<a name="l00307"></a>00307   $tolerance = $minTolerance <span class="keywordflow">if</span> $tolerance &lt; $minTolerance;
<a name="l00308"></a>00308   $tolerance = $maxTolerance <span class="keywordflow">if</span> $tolerance &gt; $maxTolerance;
<a name="l00309"></a>00309   $self-&gt;{tolerance} = $tolerance unless $self-&gt;{tolerance};
<a name="l00310"></a>00310   $self-&gt;{bisect_tolerance} = $self-&gt;{tolerance} * $self-&gt;getFlag(<span class="stringliteral">&#39;BisectionTolerance&#39;</span>)
<a name="l00311"></a>00311     unless $self-&gt;{bisect_tolerance};
<a name="l00312"></a>00312   $self-&gt;{point_tolerance} = $P * $self-&gt;getFlag(<span class="stringliteral">&#39;ImplicitPointTolerance&#39;</span>)
<a name="l00313"></a>00313     unless $self-&gt;{point_tolerance};
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <span class="preprocessor">  #</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span><span class="preprocessor">  #  Locate solutions to be used for comparison test</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span><span class="preprocessor">  #</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span>  @zero = @{$z}; @zero = $zero[0..$num_points-1] <span class="keywordflow">if</span> (scalar(@zero) &gt; $num_points);
<a name="l00319"></a>00319   <span class="keywordflow">for</span> ($i = 0; scalar(@zero) &lt; $num_points &amp;&amp; $i &lt; scalar(@intervals); $i++) {
<a name="l00320"></a>00320     my $Q = $self-&gt;Bisect($intervals[$i][0],$intervals[$i][1]);
<a name="l00321"></a>00321     push(@zero,$Q) if $Q;
<a name="l00322"></a>00322   }
<a name="l00323"></a>00323   <a class="code" href="classValue.html">Value</a>::Error(&quot;Can&#39;t find enough solutions for an effective test&quot;)
<a name="l00324"></a>00324     unless scalar(@zero) == $num_points;
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="preprocessor">#</span>
<a name="l00327"></a>00327 <span class="preprocessor"></span><span class="preprocessor">  #  Save the solutions to the equation</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span><span class="preprocessor">  #</span>
<a name="l00329"></a>00329 <span class="preprocessor"></span>  $self-&gt;{solutions} = [@zero];
<a name="l00330"></a>00330 }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 <span class="preprocessor">#</span>
<a name="l00333"></a>00333 <span class="preprocessor"></span><span class="preprocessor">#  Get random points and sort them by sign of the function.</span>
<a name="l00334"></a>00334 <span class="preprocessor"></span><span class="preprocessor">#  Also, get the average function value, and indicate if</span>
<a name="l00335"></a>00335 <span class="preprocessor"></span><span class="preprocessor">#  we actually did find both positive and negative values.</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00337"></a>00337 <span class="preprocessor"></span>sub getPositiveNegativeZero {
<a name="l00338"></a>00338   my $self = shift; my $n = shift;
<a name="l00339"></a>00339   my ($p,$v) = $self-&gt;SUPER::createRandomPoints(3*$n);
<a name="l00340"></a>00340   my (@pos,@neg,@zero);
<a name="l00341"></a>00341   my $f = 0; my $k = 0;
<a name="l00342"></a>00342   <span class="keywordflow">foreach</span> my $i (0..scalar(@{$v})-1) {
<a name="l00343"></a>00343     <span class="keywordflow">if</span> ($v-&gt;[$i] == 0) {push(@zero,$p-&gt;[$i])} <span class="keywordflow">else</span> {
<a name="l00344"></a>00344       $f += abs($v-&gt;[$i]); $k++;
<a name="l00345"></a>00345       <span class="keywordflow">if</span> ($v-&gt;[$i] &gt; 0) {push(@pos,$p-&gt;[$i])} <span class="keywordflow">else</span> {push(@neg,$p-&gt;[$i])}
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347   }
<a name="l00348"></a>00348   $f /= $k <span class="keywordflow">if</span> $k;
<a name="l00349"></a>00349   <span class="keywordflow">return</span> (scalar(@pos) &amp;&amp; scalar(@neg),[@pos],[@neg],[@zero],$f);
<a name="l00350"></a>00350 }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 <span class="preprocessor">#</span>
<a name="l00353"></a>00353 <span class="preprocessor"></span><span class="preprocessor">#  Make a list of positive and negative points sorted by</span>
<a name="l00354"></a>00354 <span class="preprocessor"></span><span class="preprocessor">#  the distance between them.  Also return the average distance</span>
<a name="l00355"></a>00355 <span class="preprocessor"></span><span class="preprocessor">#  between points.</span>
<a name="l00356"></a>00356 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span>sub getIntervals {
<a name="l00358"></a>00358   my $self = shift; my $pos = shift; my $neg = shift;
<a name="l00359"></a>00359   my @intervals = (); my $D = 0;
<a name="l00360"></a>00360   my $point = $self-&gt;Package(<span class="stringliteral">&quot;Point&quot;</span>);
<a name="l00361"></a>00361   my $context = $self-&gt;context;
<a name="l00362"></a>00362   <span class="keywordflow">foreach</span> my $p (@{$pos}) {
<a name="l00363"></a>00363     <span class="keywordflow">foreach</span> my $n (@{$neg}) {
<a name="l00364"></a>00364       my $d = abs($point-&gt;make($context,@{$p}) - $point-&gt;make($context,@{$n}));
<a name="l00365"></a>00365       push(@intervals,[$p,$n,$d]); $D += $d;
<a name="l00366"></a>00366     }
<a name="l00367"></a>00367   }
<a name="l00368"></a>00368   @intervals = main::PGsort(sub {$_[0]-&gt;[2] &lt; $_[1]-&gt;[2]},@intervals);
<a name="l00369"></a>00369   <span class="keywordflow">return</span>($D/scalar(@intervals),@intervals);
<a name="l00370"></a>00370 }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 <span class="preprocessor">#</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span><span class="preprocessor">#  Use bisection algorithm to find a point where the function is zero</span>
<a name="l00374"></a>00374 <span class="preprocessor"></span><span class="preprocessor">#  (i.e., where the original equation is an equality)</span>
<a name="l00375"></a>00375 <span class="preprocessor"></span><span class="preprocessor">#  If we can&#39;t find a point (e.g., we are at a discontinuity),</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span><span class="preprocessor">#  return an undefined value.</span>
<a name="l00377"></a>00377 <span class="preprocessor"></span><span class="preprocessor">#</span>
<a name="l00378"></a>00378 <span class="preprocessor"></span>sub Bisect {
<a name="l00379"></a>00379   my $self = shift;
<a name="l00380"></a>00380   my $tolerance  = $self-&gt;getFlag(<span class="stringliteral">&#39;bisect_tolerance&#39;</span>,1E-5);
<a name="l00381"></a>00381   my $ptolerance = $self-&gt;getFlag(<span class="stringliteral">&#39;point_tolerance&#39;</span>,1E-9);
<a name="l00382"></a>00382   my $m = $self-&gt;getFlag(<span class="stringliteral">&#39;BisectionCutoff&#39;</span>,30); my ($P,$f);
<a name="l00383"></a>00383   my $point = $self-&gt;Package(<span class="stringliteral">&quot;Point&quot;</span>); my $context = $self-&gt;context;
<a name="l00384"></a>00384   my $P0 = $point-&gt;make($context,@{$_[0]}); my $P1 = $point-&gt;make($context,@{$_[1]});
<a name="l00385"></a>00385   my ($f0,$f1) = @{$self-&gt;createPointValues([$P0-&gt;data,$P1-&gt;data],1)};
<a name="l00386"></a>00386   <span class="keywordflow">for</span> (my $i = 0; $i &lt; $m; $i++) {
<a name="l00387"></a>00387     $P = ($P0+$P1)/2; $f = $self-&gt;createPointValues([$P-&gt;data]);
<a name="l00388"></a>00388     <span class="keywordflow">return</span> unless ref($f);
<a name="l00389"></a>00389     $f = $f-&gt;[0];
<a name="l00390"></a>00390     <span class="keywordflow">return</span> [$P-&gt;value] <span class="keywordflow">if</span> abs($f) &lt; $tolerance &amp;&amp; abs($P1-$P0) &lt; $ptolerance;
<a name="l00391"></a>00391     <span class="keywordflow">if</span> ($f &gt; 0) {$P0 = $P; $f0 = $f} <span class="keywordflow">else</span> {$P1 = $P; $f1 = $f}
<a name="l00392"></a>00392   }
<a name="l00393"></a>00393   <span class="keywordflow">return</span>;
<a name="l00394"></a>00394 }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 1;
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Jun 8 22:54:55 2012 for PG by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
